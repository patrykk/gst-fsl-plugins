Description: Upstream changes introduced in version 3.0.7-2atrust1
 This patch has been created by dpkg-source during the package build.
 Here's the last changelog entry, hopefully it gives details on why
 those changes were made:
 .
 gst-fsl-plugins (3.0.7-2atrust1) t66; urgency=low
 .
   * Update to 3.0.7-2 for L3.0.35_4.1.0 MX6 release
 .
 The person named in the Author field signed this changelog entry.
Author: Atrust Corp (Atrust Development Team) <atrust@atrustcorp.com>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: http://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: <YYYY-MM-DD>

--- /dev/null
+++ gst-fsl-plugins-3.0.7/inc/core_lib/vpu_wrapper.h
@@ -0,0 +1,700 @@
+/*
+ * Copyright (c) 2010-2013, Freescale Semiconductor, Inc.
+ */
+
+/*
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+
+/*
+ *	Vpu_wrapper.h
+ *	header file contain all related vpu interface info
+ *	History :
+ *	Date	(y.m.d)		Author			Version			Description
+ *	2010-09-07		eagle zhou		0.1				Created
+ *	2011-02-17		eagle zhou		0.2				Add encoder part
+ *	2011-12-22		eagle zhou		1.0				refine api
+ *	2012-01-**		eagle zhou		1.0.*			add new features: including tile format,etc
+ */
+
+#ifndef VPU_WRAPPER_H
+#define VPU_WRAPPER_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/**************************** version info ***********************************/
+#define VPU_WRAPPER_VERSION(major, minor, release)	 \
+	(((major) << 16) + ((minor) << 8) + (release))
+#define VPU_WRAPPER_VERSION_CODE	VPU_WRAPPER_VERSION(1, 0, 35)
+
+/**************************** decoder part **********************************/
+
+#define VPU_DEC_MAX_NUM_MEM_REQS 2
+
+//typedef RetCode VpuRetCode;
+//typedef vpu_versioninfo VpuVersionInfo;
+//typedef DecHandle VpuDecHandle;
+typedef unsigned int VpuDecHandle;
+//typedef DecOpenParam VpuDecOpenParam;
+//typedef DecInitialInfo VpuSeqInfo;
+//typedef FrameBuffer VpuFrameBuffer;
+//typedef DecBufInfo VpuDecBufInfo;
+//typedef CodecCommand VpuCodecCommand;
+//typedef DecParam VpuDecParam;
+
+typedef enum {
+	VPU_DEC_ERR_UNFOUND=0,
+	VPU_DEC_ERR_NOT_SUPPORTED, /*the profile/level/features/... outrange the vpu's capability*/
+	VPU_DEC_ERR_CORRUPT, /*some syntax errors are detected*/
+}VpuDecErrInfo;
+
+typedef enum {
+	VPU_V_MPEG4 = 0,
+	VPU_V_DIVX3,
+	VPU_V_DIVX4,
+	VPU_V_DIVX56,
+	VPU_V_XVID,
+	VPU_V_H263,
+	VPU_V_AVC,
+	VPU_V_AVC_MVC,
+	VPU_V_VC1,
+	VPU_V_VC1_AP,
+	VPU_V_MPEG2,
+	VPU_V_RV,
+	VPU_V_MJPG,
+	VPU_V_AVS,
+	VPU_V_VP8,
+} VpuCodStd;
+
+typedef enum {
+	VPU_DEC_SKIPNONE=0,
+	VPU_DEC_SKIPPB,
+	VPU_DEC_SKIPB,
+	VPU_DEC_SKIPALL,
+	VPU_DEC_ISEARCH,	/*only decode IDR*/
+}VpuDecSkipMode;
+
+typedef enum {
+	VPU_DEC_IN_NORMAL=0,
+	VPU_DEC_IN_KICK,
+	VPU_DEC_IN_DRAIN,
+}VpuDecInputType;
+
+typedef enum {
+	VPU_DEC_CONF_SKIPMODE=0,		/*parameter value: VPU_DEC_SKIPNONE(default); VPU_DEC_SKIPPB; VPU_DEC_SKIPB; VPU_DEC_SKIPALL;VPU_DEC_ISEARCH*/
+	VPU_DEC_CONF_INPUTTYPE,		/*parameter value:
+										VPU_DEC_IN_NOMAL: normal(default)
+										VPU_DEC_IN_KICK: kick -- input data/size in VPU_DecDecodeBuf() will be ignored
+										VPU_DEC_IN_DRAIN: drain -- stream reach end, and input data/size in VPU_DecDecodeBuf() will be ignored
+									*/
+	//VPU_DEC_CONF_BLOCK,
+	//VPU_DEC_CONF_NONEBLOCK,
+	VPU_DEC_CONF_BUFDELAY,		/*for stream mode:
+									    parameter represent buf size(unit: bytes), buffer size==0 indicate no any delay*/
+	VPU_DEC_CONF_INIT_CNT_THRESHOLD,  /*at seqinit stage: vpu will report error if data count reach the threshold*/
+} VpuDecConfig;
+
+typedef enum 
+{
+	VPU_DEC_RET_SUCCESS = 0,
+	VPU_DEC_RET_FAILURE,
+	VPU_DEC_RET_INVALID_PARAM,
+	VPU_DEC_RET_INVALID_HANDLE,
+	VPU_DEC_RET_INVALID_FRAME_BUFFER,
+	VPU_DEC_RET_INSUFFICIENT_FRAME_BUFFERS,
+	VPU_DEC_RET_INVALID_STRIDE,
+	VPU_DEC_RET_WRONG_CALL_SEQUENCE,
+	VPU_DEC_RET_FAILURE_TIMEOUT,
+}VpuDecRetCode;
+
+typedef enum
+{
+	/* bit[0]: input buf info */
+	VPU_DEC_INPUT_NOT_USED=0x0,
+	VPU_DEC_INPUT_USED=0x1,
+	/* bit[1:6]: frame output info */
+	VPU_DEC_OUTPUT_EOS=0x2,
+	VPU_DEC_OUTPUT_DIS=0x4,			/*one frame is output*/
+	VPU_DEC_OUTPUT_NODIS=0x8,		/*no frame output*/
+	VPU_DEC_OUTPUT_REPEAT=0x10,		/*one frame is output repeatly: mainly for VC1 specification: user need to get one timestamp*/
+	VPU_DEC_OUTPUT_DROPPED=0x20,	/*for unclose gop case: (1) drop B or (2) drop non-I frame: user need to get one timestamp*/
+	VPU_DEC_OUTPUT_MOSAIC_DIS=0x40,	/*for unclose gop case: the frame will be output, but not dropped by decoder: user need to get one timestamp*/
+	/* bit[7:8]: frame output info */
+	VPU_DEC_NO_ENOUGH_BUF=0x80,		/*no enough frame buffer*/
+	VPU_DEC_NO_ENOUGH_INBUF=0x100,	/*no enough input buffer: to avoid null run*/
+	/* bit[9]: init output info */
+	VPU_DEC_INIT_OK=0x200,			/*user need to call VPU_DecGetInitialInfo()*/
+	/* bit[10]: skip decode */
+	VPU_DEC_SKIP=0x400,				/*added for cases: need to get two time stamp*/
+										/*not decoded: interlace or corrupt: user need to get one time stamp*/
+	/*bit[11]: reserved to represent one frame is decoded*/
+	VPU_DEC_ONE_FRM_CONSUMED=0x800,/*added for case: need to get decoded(or skipped,corrupt...) frame length*/
+										/*user may call related api to get the decoded/skipped/.. frame related info*/
+	/*bit[12]: reolution changed*/	
+	VPU_DEC_RESOLUTION_CHANGED=0x1000,/*added for case: upward change in resolution*/
+										/*user need to release all frames, call VPU_DecGetInitialInfo() and re-allocation/register frames according to new bigger resolution*/	
+	/* bit[31]: flush is recommended */
+	VPU_DEC_FLUSH=0x80000000,			/*for some clisps, special for h.264 TS stream(may has no IDR at all), the random start/seek point may introduce unrecoverable mosaic*/
+}VpuDecBufRetCode;
+
+typedef enum {
+	VPU_DEC_CAP_FILEMODE=0,	/* file mode is supported ? 0: not; 1: yes*/
+	VPU_DEC_CAP_TILE,			/* tile format is supported ? 0: not; 1: yes*/
+	VPU_DEC_CAP_FRAMESIZE,	/* reporting frame size  ? 0: not; 1: yes*/
+	VPU_DEC_CAP_RESOLUTION_CHANGE, /*resolution change notification ? 0: not; 1: yes*/
+}VpuDecCapability;
+
+typedef enum 
+{
+	VPU_MEM_VIRT   = 0,    	/* 0 for virtual Memory */
+	VPU_MEM_PHY    = 1,		/* 1 for physical continuous Memory */
+}VpuMemType;
+
+typedef enum
+{
+	VPU_I_PIC=0,			/*I frame or I sclie(H.264)*/
+	VPU_P_PIC,				/*P frame or P sclie(H.264)*/
+	VPU_B_PIC,				/*B frame or B sclie(H.264)*/
+	VPU_IDR_PIC,			/*IDR frame(H.264)*/
+	VPU_BI_PIC,				/*BI frame(VC1)*/
+	VPU_SKIP_PIC,			/*Skipped frame(VC1)*/
+	VPU_UNKNOWN_PIC,		/*reserved*/
+}VpuPicType;
+
+typedef enum
+{
+	VPU_FIELD_NONE=0,		/*frame*/
+	VPU_FIELD_TOP,			/*only top field*/
+	VPU_FIELD_BOTTOM,		/*only bottom field*/
+	VPU_FIELD_TB,			/*top field + bottom field*/
+	VPU_FIELD_BT,			/*bottom field + top field*/
+	VPU_FIELD_UNKNOWN,	/*reserved*/
+}VpuFieldType;
+
+typedef struct {
+	int nAlignment;			/* alignment limitation */
+	int	nSize;				/* Size in bytes */
+	VpuMemType MemType; /* Flag to indicate Static, Scratch or output data memory */
+	unsigned char* pVirtAddr;		/* virtual address:Pointer to the base memory , which will be allocated and filled by the application*/
+	unsigned char* pPhyAddr;		/* physical address: Pointer to the base memory , which will be allocated and filled by the application*/
+
+	int nReserved[3];				/*reserved for future extension*/
+} VpuMemSubBlockInfo;
+
+typedef struct{
+	int nSubBlockNum;
+	VpuMemSubBlockInfo MemSubBlock[VPU_DEC_MAX_NUM_MEM_REQS];
+}VpuMemInfo;
+
+
+typedef struct 
+{
+	int nFwMajor;		/* firmware major version */
+	int nFwMinor;		/* firmware minor version */
+	int nFwRelease;		/* firmware release version */
+	int nFwCode;			/* firmware code version */
+	int nLibMajor;		/* library major version */
+	int nLibMinor;		/* library minor version */
+	int nLibRelease;		/* library release version */
+	int nReserved;		/*reserved for future extension*/
+}VpuVersionInfo;
+
+typedef struct 
+{
+	int nMajor;		/* major version */
+	int nMinor;		/* minor version */
+	int nRelease;		/* release version */
+	char* pBinary;	/* version info specified by user(such as build time), below is one example in makefile:
+					     CFLAGS+=-DUSER_SPECIFY_BINARY_VER -DSTR_USER_SPECIFY_BINARY_VER=\"binary version specified by user\"
+					*/
+	int nReserved[4];	/*reserved for future extension*/
+}VpuWrapperVersionInfo;
+
+typedef struct {
+	VpuCodStd CodecFormat;
+	//unsigned int bitstreamBuffer;
+	//int bitstreamBufferSize;
+	//int qpReport;
+	//int mp4DeblkEnable;
+	int nReorderEnable;
+	int nChromaInterleave;	//should be set to 1 when (nMapType!=0)
+	int nMapType;			//registered frame buffer type: 0--linear; 1--frame tile; 2--field tile
+	int nTiled2LinearEnable;	//output frame(only valid when nMapType!=0) : 0--tile. eg. same with registered frame ; 1--linear(not supported)  
+	//int filePlayEnable;
+	int nPicWidth;
+	int nPicHeight;
+	//int dynamicAllocEnable;
+	//int streamStartByteOffset;
+	//int mjpg_thumbNailDecEnable;
+	//unsigned int psSaveBuffer;
+	//int psSaveBufferSize;
+	//int mp4Class;
+	//int block;
+	int nEnableFileMode;
+
+	int nReserved[3];			/*reserved for future extension*/
+	void* pAppCxt;			/*reserved for future application extension*/
+} VpuDecOpenParam;
+
+
+typedef struct {
+	/* stride info */
+	unsigned int nStrideY;
+	unsigned int nStrideC;
+
+	/* physical address */
+	unsigned char* pbufY;			//luma frame pointer or top field pointer(for field tile)
+	unsigned char* pbufCb;		//chroma frame pointer or top field pointer(for field tile)
+	unsigned char* pbufCr;
+	unsigned char* pbufMvCol;
+	unsigned char* pbufY_tilebot;	//for field tile: luma bottom pointer
+	unsigned char* pbufCb_tilebot;	//for field tile: chroma bottom pointer
+	//unsigned char* pbufCr_tilebot;	//not required since always enable interleave for tile
+
+	/* virtual address */
+	unsigned char* pbufVirtY;		//luma frame pointer or top field pointer(for field tile)
+	unsigned char* pbufVirtCb;		//chroma frame pointer or top field pointer(for field tile)
+	unsigned char* pbufVirtCr;
+	unsigned char* pbufVirtMvCol;
+	unsigned char* pbufVirtY_tilebot;	//for field tile: luma bottom pointer
+	unsigned char* pbufVirtCb_tilebot;	//for field tile: chroma bottom pointer
+	//unsigned char* pbufVirtCr_tilebot;	//not required since always enable interleave for tile
+
+	int nReserved[5];				/*reserved for future extension*/
+	void* pPrivate;				/*reserved for future special extension*/
+} VpuFrameBuffer;
+
+typedef struct {
+	unsigned int nLeft;
+	unsigned int nTop;
+	unsigned int nRight;
+	unsigned int nBottom;
+} VpuRect;
+
+//typedef struct {
+//	unsigned int sliceSaveBuffer;
+//	int sliceSaveBufferSize;
+//} VpuDecAvcSliceBufInfo;
+
+//typedef struct {
+//	VpuDecAvcSliceBufInfo avcSliceBufInfo;
+//} VpuDecBufInfo;
+
+
+typedef struct {
+	int nPicWidth;		// {(PicX+15)/16} * 16
+	int nPicHeight;		// {(PicY+15)/16} * 16
+	int nFrameRateRes;	// frameinfo: numerator.  <=0 represent invalid
+	int nFrameRateDiv;	// frameinfo: denominator. <=0 represent invalid
+	VpuRect PicCropRect;
+
+	//int mp4_dataPartitionEnable;
+	//int mp4_reversibleVlcEnable;
+	//int mp4_shortVideoHeader;
+	//int h263_annexJEnable;
+
+	int nMinFrameBufferCount;
+	//int frameBufDelay;
+	//int nextDecodedIdxNum;
+	//int normalSliceSize;
+	//int worstSliceSize;
+	//int mjpg_thumbNailEnable;
+	int nMjpgSourceFormat;
+
+	//int streamInfoObtained;
+	//int profile;
+	//int level;
+	int nInterlace;
+	//int constraint_set_flag[4];
+	//int direct8x8Flag;
+	//int vc1_psf;
+	unsigned int nQ16ShiftWidthDivHeightRatio;	//fixed point for width/height: 1: 0x10000; 0.5: 0x8000;...
+	//Uint32 errorcode;
+	int nConsumedByte;		/*reserved to record sequence length: value -1 indicate unknow*/
+	//DecReportBufSize reportBufSize;
+	int nAddressAlignment;	/*address alignment for Y/Cb/Cr (unit: bytes)*/
+
+	int nReserved[5];			/*reserved for future extension*/
+	void* pSpecialInfo;		/*reserved for future special extension*/
+} VpuDecInitInfo;
+
+/*
+typedef struct {
+	//int prescanEnable;
+	//int prescanMode;
+	//int dispReorderBuf;
+	//int iframeSearchEnable;
+	int skipframeMode;
+	//int skipframeNum;
+#if 0  //move into 	VPU_DecDecBuf(..., VpuBufferNode* pInData,...)
+	int chunkSize;
+	int picStartByteOffset;
+	unsigned int picStreamBufferAddr;
+#endif	
+} VpuDecParam;
+*/
+
+typedef struct {
+	int nFrmWidth;			/*support dynamic resolution*/
+	int nFrmHeight;			/*support dynamic resolution*/
+	VpuRect FrmCropRect;	/*support dynamic resolution*/
+	unsigned int nQ16ShiftWidthDivHeightRatio;	/*support dynamic ratio, refer to definition in struct 'VpuDecInitInfo'*/
+	int nReserved[9];		/*reserved for recording other info*/
+}VpuFrameExtInfo;
+
+typedef struct {
+	//int indexFrameDisplay;
+	//int indexFrameDecoded;
+	VpuFrameBuffer * pDisplayFrameBuf;
+	//VpuFrameBuffer * pDecodedFrameBuf;
+	//int NumDecFrameBuf;
+	VpuPicType ePicType;
+	//int numOfErrMBs;
+	//Uint32 *qpInfo;
+	//int hScaleFlag;
+	//int vScaleFlag;
+	//int indexFrameRangemap;
+	//int prescanresult;
+	//int notSufficientPsBuffer;
+	//int notSufficientSliceBuffer;
+	//int decodingSuccess;
+	//int interlacedFrame;
+	//int mp4PackedPBframe;
+	//int h264Npf;
+
+	//int pictureStructure;
+	//int nTopFieldFirst;
+	//int nRepeatFirstField;
+	//union {
+	//    int progressiveFrame;
+	//    int vc1_repeatFrame;
+	//};
+	//int fieldSequence;
+
+	//int decPicHeight;
+	//int decPicWidth;
+	//Rect decPicCrop;
+
+	//DecReportInfo mbInfo;
+	//DecReportInfo mvInfo;
+	//DecReportInfo frameBufStat;
+	//DecReportInfo userData;
+	//int nConsumedByte;		/*reserved to record frame length: value -1 indicate unknow*/
+	VpuFieldType	eFieldType;	/*added for user to implement deinterlace process*/
+	int nMVCViewID;	/*used to indicate which view of MVC clips*/
+
+	VpuFrameExtInfo * pExtInfo;	/*extended info: support dynamic resolution, ...*/
+	int nReserved[2];			/*reserved for future extension*/
+	void* pPrivate;			/*reserved for future special extension*/
+} VpuDecOutFrameInfo;
+
+
+typedef struct
+{
+	unsigned char* pData;		/*buffer virtual addr*/
+	unsigned int nSize;		/*valid data length */	
+}VpuCodecData;
+
+
+typedef struct
+{
+	unsigned char* pPhyAddr;	/*buffer physical base addr*/
+	unsigned char* pVirAddr;	/*buffer virtual base addr*/
+	unsigned int nSize;		/*valid data length */
+	VpuCodecData sCodecData;	/*private data specified by codec*/
+
+	int nReserved[2];				/*reserved for future extension*/
+	void* pPrivate;				/*reserved for future special extension*/
+}VpuBufferNode;
+
+typedef struct 
+{
+	int nSize;				/*!requested memory size */
+	unsigned long nPhyAddr;	/*!physical memory address allocated */
+	unsigned long nCpuAddr;	/*!cpu addr for system free usage */
+	unsigned long nVirtAddr;	/*!virtual user space address */	
+	int nReserved[4];			/*reserved for future extension*/
+}VpuMemDesc;
+
+typedef struct {
+	VpuFrameBuffer* pFrame;	/*point to the frame buffer. if it is NULL, it represent the frame is skipped by vpu, but the other length info are still valid*/
+	int nStuffLength;			/*stuff data length ahead of frame. If it is < 0, mean the config data contain some valid frames, user need to process this case carefully*/
+	int nFrameLength;		/*valid frame length: should be > 0*/
+	int nReserved[5];			/*reserved for recording other info*/
+}VpuDecFrameLengthInfo;
+
+/**************************** encoder part **********************************/
+
+typedef unsigned int VpuEncHandle;
+
+typedef enum
+{
+	/*the value comply with the vpu lib header file, don't change it !*/
+	VPU_COLOR_420=0,
+	VPU_COLOR_422H=1,
+	VPU_COLOR_422V=2,
+	VPU_COLOR_444=3,	
+	VPU_COLOR_400=4,
+}VpuColorFormat;
+
+typedef enum {
+	VPU_ENC_MIRDIR_NONE,
+	VPU_ENC_MIRDIR_VER,
+	VPU_ENC_MIRDIR_HOR,
+	VPU_ENC_MIRDIR_HOR_VER
+} VpuEncMirrorDirection;
+
+typedef struct {
+	int nMinFrameBufferCount;
+	int nAddressAlignment;		/*address alignment for Y/Cb/Cr (unit: bytes)*/
+} VpuEncInitInfo;
+
+typedef enum 
+{
+	VPU_ENC_RET_SUCCESS = 0,
+	VPU_ENC_RET_FAILURE,
+	VPU_ENC_RET_INVALID_PARAM,
+	VPU_ENC_RET_INVALID_HANDLE,
+	VPU_ENC_RET_INVALID_FRAME_BUFFER,
+	VPU_ENC_RET_INSUFFICIENT_FRAME_BUFFERS,
+	VPU_ENC_RET_INVALID_STRIDE,
+	VPU_ENC_RET_WRONG_CALL_SEQUENCE,
+	VPU_ENC_RET_FAILURE_TIMEOUT,
+}VpuEncRetCode;
+
+typedef enum
+{
+	/* bit[0]: input buf info */
+	VPU_ENC_INPUT_NOT_USED=0x0,
+	VPU_ENC_INPUT_USED=0x1,
+	/* bit[1:4]: frame output info */
+	//VPU_ENC_OUTPUT_EOS=,
+	VPU_ENC_OUTPUT_SEQHEADER=0x4,	/*sequence header(for H.264: SPS/PPS)*/
+	VPU_ENC_OUTPUT_DIS=0x8,
+	VPU_ENC_OUTPUT_NODIS=0x10,
+	//VPU_ENC_OUTPUT_REPEAT=,	
+}VpuEncBufRetCode;
+
+typedef struct {
+	VpuCodStd eFormat;
+	int nPicWidth;
+	int nPicHeight;	
+	int nRotAngle;
+	int nFrameRate;
+	int nBitRate;				/*unit: kbps*/
+	int nGOPSize;
+	int nChromaInterleave;	/*should be set to 1 when (nMapType!=0)*/
+	VpuEncMirrorDirection sMirror;
+	//int nQuantParam;
+	int nMapType;			/*frame buffer: 0--linear ; 1--frame tile; 2--field tile*/
+	int nLinear2TiledEnable; 	/*valid when (nMapType!=0): 0--tile input; 1--yuv input*/
+	VpuColorFormat eColorFormat;	/*only MJPG support non-420*/
+
+	int nReserved[3];				/*reserved for future extension*/
+	void* pAppCxt;				/*reserved for future extension*/
+} VpuEncOpenParamSimp;
+
+typedef struct {
+	int sliceMode;
+	int sliceSizeMode;
+	int sliceSize;
+	int nReserved;			/*reserved for future extension*/
+} VpuEncSliceMode;
+
+typedef struct {
+	int mp4_dataPartitionEnable;
+	int mp4_reversibleVlcEnable;
+	int mp4_intraDcVlcThr;
+	int mp4_hecEnable;
+	int mp4_verid;
+	int nReserved[3];			/*reserved for future extension*/
+} VpuEncMp4Param;
+
+typedef struct {
+	int h263_annexIEnable;	
+	int h263_annexJEnable;
+	int h263_annexKEnable;
+	int h263_annexTEnable;
+	int nReserved[4];			/*reserved for future extension*/
+} VpuEncH263Param;
+
+typedef struct {
+	int avc_constrainedIntraPredFlag;
+	int avc_disableDeblk;
+	int avc_deblkFilterOffsetAlpha;
+	int avc_deblkFilterOffsetBeta;
+	int avc_chromaQpOffset;
+	int avc_audEnable;
+	int avc_fmoEnable;
+	int avc_fmoSliceNum;
+	int avc_fmoType;
+	int avc_fmoSliceSaveBufSize;
+	int nReserved[6];				/*reserved for future extension*/
+} VpuEncAvcParam;
+
+typedef struct {
+	VpuCodStd eFormat;
+	int nPicWidth;
+	int nPicHeight;	
+	int nRotAngle;
+	int nFrameRate;
+	int nBitRate;				/*unit: kbps*/
+	int nGOPSize;
+	int nChromaInterleave;	/*should be set to 1 when (nMapType!=0)*/
+	VpuEncMirrorDirection sMirror;
+	//int nQuantParam;
+	int nMapType;			/*frame buffer: 0--linear ; 1--frame tile; 2--field tile*/
+	int nLinear2TiledEnable; 	/*valid when (nMapType!=0): 0--tile input; 1--yuv input*/
+	VpuColorFormat eColorFormat;	/*only MJPG support non-420*/
+
+	int nUserQpMax;
+	int nUserQpMin;
+	int nUserQpMinEnable;
+	int nUserQpMaxEnable;
+
+	int nIntraRefresh;
+	int nRcIntraQp;
+
+	int nUserGamma;
+	int nRcIntervalMode;		/* 0:normal, 1:frame_level, 2:slice_level, 3: user defined Mb_level */
+	int nMbInterval;			/* use when RcintervalMode is 3 */
+	int nAvcIntra16x16OnlyModeEnable;
+	
+	VpuEncSliceMode sliceMode;
+
+	int nInitialDelay;
+	int nVbvBufferSize;
+	union {
+		VpuEncMp4Param mp4Param;
+		VpuEncH263Param h263Param;
+		VpuEncAvcParam avcParam;
+		//EncMjpgParam mjpgParam;
+	} VpuEncStdParam;
+
+	int nMESearchRange;      // 3: 16x16, 2:32x16, 1:64x32, 0:128x64, H.263(Short Header : always 3)
+	int nMEUseZeroPmv;       // 0: PMV_ENABLE, 1: PMV_DISABLE
+	int nIntraCostWeight;    // Additional weight of Intra Cost for mode decision to reduce Intra MB density
+
+	int nReserved[8];				/*reserved for future extension*/
+	void* pAppCxt;			/*reserved for future extension*/
+} VpuEncOpenParam;
+
+typedef struct {
+//[IN]	
+	VpuCodStd eFormat;
+	int nPicWidth;
+	int nPicHeight;	
+	int nFrameRate;
+	int nQuantParam;
+
+	unsigned int nInPhyInput;	//input buffer address
+	unsigned int nInVirtInput;
+	int nInInputSize;	
+	unsigned int nInPhyOutput;	//output frame address
+	unsigned int nInVirtOutput;
+	unsigned int nInOutputBufLen;
+
+	/*advanced options*/
+	int nForceIPicture;
+	int nSkipPicture;
+	int nEnableAutoSkip;
+	
+//[OUT]	
+	VpuEncBufRetCode eOutRetCode;
+	int nOutOutputSize;
+//[Reserved]
+	VpuFrameBuffer * pInFrame;/*extended for advanced user to set crop info: if this pointer isn't null, the Y/Cb/Cr address in this struct will be adopted*/
+	int nReserved[2];			/*reserved for future extension*/
+	void* pPrivate;			/*reserved for future extension*/
+} VpuEncEncParam;
+
+typedef enum {
+	VPU_ENC_CONF_NONE=0,
+	//VPU_DEC_CONF_SKIPPB,
+	//VPU_DEC_CONF_SKIPB,	
+	//VPU_DEC_CONF_SKIPALL,
+	//VPU_DEC_CONF_ISEARCH,
+	//VPU_DEC_CONF_BLOCK,
+	//VPU_DEC_CONF_NONEBLOCK,
+	VPU_ENC_CONF_BIT_RATE,  /*parameter: kbps*/
+} VpuEncConfig;
+
+
+
+/********************************** decoder APIs ***************************************/
+
+VpuDecRetCode VPU_DecLoad();
+VpuDecRetCode VPU_DecGetVersionInfo(VpuVersionInfo * pOutVerInfo);
+VpuDecRetCode VPU_DecGetWrapperVersionInfo(VpuWrapperVersionInfo * pOutVerInfo);
+VpuDecRetCode VPU_DecQueryMem(VpuMemInfo* pOutMemInfo);
+VpuDecRetCode VPU_DecOpen(VpuDecHandle *pOutHandle, VpuDecOpenParam * pInParam,VpuMemInfo* pInMemInfo);
+VpuDecRetCode VPU_DecGetCapability(VpuDecHandle InHandle,VpuDecCapability eInCapability, int* pOutCapbility);
+VpuDecRetCode VPU_DecDisCapability(VpuDecHandle InHandle,VpuDecCapability eInCapability);
+
+//VpuDecRetCode VPU_DecSeqInit(VpuDecHandle InHandle, VpuBufferNode* pInData, VpuSeqInfo * pOutInfo);
+VpuDecRetCode VPU_DecConfig(VpuDecHandle InHandle, VpuDecConfig InDecConf, void* pInParam); 
+VpuDecRetCode VPU_DecDecodeBuf(VpuDecHandle InHandle, VpuBufferNode* pInData,int* pOutBufRetCode);
+VpuDecRetCode VPU_DecGetInitialInfo(VpuDecHandle InHandle, VpuDecInitInfo * pOutInitInfo);
+
+VpuDecRetCode VPU_DecRegisterFrameBuffer(VpuDecHandle InHandle,VpuFrameBuffer *pInFrameBufArray, int nNum);
+
+VpuDecRetCode VPU_DecGetOutputFrame(VpuDecHandle InHandle, VpuDecOutFrameInfo * pOutFrameInfo);
+VpuDecRetCode VPU_DecGetConsumedFrameInfo(VpuDecHandle InHandle,VpuDecFrameLengthInfo* pOutFrameInfo);
+
+VpuDecRetCode VPU_DecOutFrameDisplayed(VpuDecHandle InHandle, VpuFrameBuffer* pInFrameBuf);
+
+//VpuDecRetCode VPU_DecFlushLeftStream(VpuDecHandle InHandle);
+//VpuDecRetCode VPU_DecFlushLeftFrame(VpuDecHandle InHandle);
+VpuDecRetCode VPU_DecFlushAll(VpuDecHandle InHandle);
+VpuDecRetCode VPU_DecAllRegFrameInfo(VpuDecHandle InHandle, VpuFrameBuffer** ppOutFrameBuf, int* pOutNum);
+
+VpuDecRetCode VPU_DecClose(VpuDecHandle InHandle);
+VpuDecRetCode VPU_DecUnLoad();
+
+VpuDecRetCode VPU_DecReset(VpuDecHandle InHandle);
+VpuDecRetCode VPU_DecGetErrInfo(VpuDecHandle InHandle,VpuDecErrInfo* pErrInfo);
+
+VpuDecRetCode VPU_DecGetMem(VpuMemDesc* pInOutMem);
+VpuDecRetCode VPU_DecFreeMem(VpuMemDesc* pInMem);
+
+/********************************** encoder APIs ***************************************/
+VpuEncRetCode VPU_EncLoad();
+VpuEncRetCode VPU_EncUnLoad();
+VpuEncRetCode VPU_EncReset(VpuEncHandle InHandle);
+VpuEncRetCode VPU_EncOpenSimp(VpuEncHandle *pOutHandle, VpuMemInfo* pInMemInfo,VpuEncOpenParamSimp * pInParam);
+VpuEncRetCode VPU_EncOpen(VpuEncHandle *pOutHandle, VpuMemInfo* pInMemInfo,VpuEncOpenParam* pInParam);
+VpuEncRetCode VPU_EncClose(VpuEncHandle InHandle);
+VpuEncRetCode VPU_EncGetInitialInfo(VpuEncHandle InHandle, VpuEncInitInfo * pOutInitInfo);
+VpuEncRetCode VPU_EncGetVersionInfo(VpuVersionInfo * pOutVerInfo);
+VpuDecRetCode VPU_EncGetWrapperVersionInfo(VpuWrapperVersionInfo * pOutVerInfo);
+VpuEncRetCode VPU_EncRegisterFrameBuffer(VpuEncHandle InHandle,VpuFrameBuffer *pInFrameBufArray, int nNum,int nSrcStride);
+VpuEncRetCode VPU_EncQueryMem(VpuMemInfo* pOutMemInfo);
+VpuEncRetCode VPU_EncGetMem(VpuMemDesc* pInOutMem);
+VpuEncRetCode VPU_EncFreeMem(VpuMemDesc* pInMem);
+VpuEncRetCode VPU_EncConfig(VpuEncHandle InHandle, VpuEncConfig InEncConf, void* pInParam);
+VpuEncRetCode VPU_EncEncodeFrame(VpuEncHandle InHandle, VpuEncEncParam* pInOutParam);
+VpuEncRetCode VPU_EncEncodeFrame(VpuEncHandle InHandle, VpuEncEncParam* pInOutParam);
+
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif  //#ifndef VPU_WRAPPER_H
+
--- /dev/null
+++ gst-fsl-plugins-3.0.7/inc/core_lib/wmv9mp_dec_api.h
@@ -0,0 +1,512 @@
+/*
+ * Copyright (c) 2005-2010, 2013 Freescale Semiconductor, Inc.
+ */
+
+/*
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+/************************************************************************
+*
+* File Name: wmv9_dec_api.h
+*
+* Description: This header file describes all the enumerations, data types,
+*              structures, macros and functions to be exposed to the
+*              application developers.
+*
+****************************** Change History**************************
+*
+*    DD/MMM/YYYY     Code Ver     Description            Author
+*    -----------     --------     -----------            ------
+* 01 Feb 2005        0.1       Intial version            Debashis Sarkar
+* 04 Feb 2005        0.2       First version that runs   Debashis
+* 16 Feb 2005        0.3       Review comments           Debashis
+* 23 Aug 2006        0.4       Updated for UYVY          Prachi/Pavan
+*                              support:TLSbo75126
+* 24 Nov 2006        0.5       Increased the maximum     Abhishek M
+*                              number of mem requests
+*                              from 256 to 512.
+*                              Added an memory type
+*                              to indicate
+*                              whether buffer holds the
+*                              output (TLSbo79957)
+* 2 Jan 2007         0.6       Changes for getting       Abhishek M
+*                              padded/non-padded o/p
+* 6 Jun 2007         0.7       Interface Changes for     Jayendran R
+*                              aiding in direct
+*                              rendering (ENGR40526)
+***********************************************************************/
+
+/******************************************************************
+ *MAD ShangHai Change History
+ * Nov/30/2007 - Ding Qiang Add Direct Rendering
+ * 06 Aug 2009       Eagle Zhou                ENGR00114778 : add dropping B frames
+ ******************************************************************/
+#ifndef WMV9_DEC_API_H
+#define WMV9_DEC_API_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*********** Basic data types ***********/
+
+typedef void               WMV9D_Void;
+
+typedef int                WMV9D_S32;
+typedef unsigned int       WMV9D_U32;
+
+typedef short int          WMV9D_S16;
+typedef short unsigned int WMV9D_U16;
+
+typedef char               WMV9D_S8;
+typedef unsigned char      WMV9D_U8;
+
+
+/******** Call back function pointer type, used in data retrieving *********/
+
+typedef WMV9D_S32 (*FpWmv9DecReadCbkType) (WMV9D_S32 s32BufLen,
+                                           WMV9D_U8* pu8Buf,
+                                           WMV9D_S32* bEndOfFrame,
+                                           WMV9D_Void* pvAppContext);
+
+
+/**************        Macro definitions        *****************/
+
+/* memory types not exactly a bitfield, but could have been */
+
+/* Slow memory is reasonable, and expected */
+#define WMV9D_SLOW_MEMORY       0x0001
+
+/* Fast memory is adviced and desirable. It will have impact on performance */
+#define WMV9D_FAST_MEMORY       0x0002
+
+/* Memory content is used over API calls, and can not be reused in between */
+#define WMV9D_STATIC_MEMORY     0x0004
+
+/* Memory content is not used over API calls, and can be reused in between */
+#define WMV9D_SCRATCH_MEMORY    0x0008
+
+/* Memory required can change, depending of the frame size, or sequence */
+#define WMV9D_SIZE_DEPENDENT    0x0010
+
+/* Memory size has changed after last allocation, or it is being initialized */
+#define WMV9D_SIZE_CHANGED      0x0020
+
+/* Memory needs to be copied to new location, if reallocation happens.
+ * The size to be copied is minimum of old size and current size */
+#define WMV9D_COPY_AT_RESIZE    0x0040
+
+//#ifdef OUTPUT_BUFFER_CHANGES
+/*memory req for output buffers*/
+#define WMV9D_OUTPUT_MEMORY    0x0080
+//#endif
+
+
+
+/****** macros to extract memory types ******/
+
+/* Returns true if the memory required is fast */
+#define WMV9D_IS_FAST_MEMORY(memType)       ((memType) & WMV9D_FAST_MEMORY)
+
+/* Returns true if the memory reuired can be slow */
+#define WMV9D_IS_SLOW_MEMORY(memType)       ((memType) & WMV9D_SLOW_MEMORY)
+
+
+/* Returns true if the memory usage is static type */
+#define WMV9D_IS_STATIC_MEMORY(memType)     ((memType) & WMV9D_STATIC_MEMORY)
+
+/* Returns true if the memory content is not used over API calls */
+#define WMV9D_IS_SCRATCH_MEMORY(memType)    ((memType) & WMV9D_SCRATCH_MEMORY)
+
+
+/* Returns true, if the buffer size depends on frame size and/or sequence */
+#define WMV9D_IS_SIZE_DEPENDENT_MEMORY(memType) \
+                                            ((memType) & WMV9D_SIZE_DEPENDENT)
+
+/* Returns true if the buffer size has changed after last allocation */
+#define WMV9D_IS_SIZE_CHANGED(memType)      ((memType) & WMV9D_SIZE_CHANGED)
+
+/* Returns true, if the buffer needs to be copied while reallocating */
+#define WMV9D_NEEDS_COPY_AT_RESIZE(memType) ((memType) & WMV9D_COPY_AT_RESIZE)
+
+/* Returns true, if the buffer holds output data */
+//#ifdef OUTPUT_BUFFER_CHANGES
+#define WMV9D_IS_OUTPUT_MEMORY(memType)     ((memType) & WMV9D_OUTPUT_MEMORY)
+//#endif
+/*
+ * Define to control the loging level. Can be set from build command or here.
+ * The debug levels are currently defined at 4 levels, sequence layer [bit0],
+ * frame layer [bit1], macroblock layer [bit3] and block layer [bit4]. There
+ * is no debug level for each pixel, as it is too much of data to handle. To
+ * enable debug at any level, set the corresponding bit to 1. To enable
+ * function entry and exit, use bit7. Please note that function entry and
+ * exit will be loged only for the levels, where the debug is on.
+ */
+
+//#ifndef WMV9_DEBUG_LEVEL
+//#define WMV9_DEBUG_LEVEL  0x00    /* no debugging is set */
+//#endif
+
+
+/*
+ * Maximum number of memory requests that can be made by the decoder. Do not
+ * modify this value.
+ */
+//#ifndef WMV9_SIMPLE_ONLY
+#define WMV9D_MAX_NUM_MEM_REQS              512
+//#else
+//#define WMV9D_MAX_NUM_MEM_REQS              256
+//#endif
+
+/*
+ * Bit buffer size used by the decoder. The memory required for this is
+ * allocated through memquery API as fast memory. Do not make it huge, as
+ * it is never required to hold more than one frame worth data at any given
+ * time. It may contain part of one frames data, if frame data size is larger.
+ */
+
+#define WMV9D_BIT_BUFFER_LENGTH    256
+
+
+/*********** enumeration types ***********/
+
+/*
+ * Return types from all of the decoder API's, except the format converter
+ */
+
+typedef enum
+{
+    /* Successfull return values */
+    E_WMV9D_SUCCESS = 0,          /* Successful completion                  */
+
+    /* Successful return with a warning, no action needs to be taken        */
+    E_WMV9D_ERROR_CONCEALED = 11, /* Error in the bit stream, but concealed */
+    E_WMV9D_ENDOF_BITSTREAM,      /* End of Bit Stream                      */
+//#if SKIP_ENABLE//ENGR38817
+    E_WMV9D_SKIPPED_FRAME,        /* The frame has been skipped             */
+//#endif
+    /* Successful return with a warning, correct the situation and continue */
+    E_WMV9D_NOT_ENOUGH_BITS=31,   /* Not enough bits are provided           */
+    E_WMV9D_BAD_MEMORY,           /* Out of memory                          */
+    E_WMV9D_WRONG_ALIGNMENT,      /* Incorrect memory alignment             */
+    E_WMV9D_SIZE_CHANGED,         /* Image size changed                     */
+    E_WMV9D_NO_OUTPUT,            /* No output frame is available           */
+    E_WMV9D_BROKEN_FRAME,         /* Should have more data in this frame    */
+	E_WMV9D_DEMO_PROTECT,		   /* the output is corrupted by demo protection	*/
+
+    /* irrecoverable error type, may need re-initialization to continue     */
+    E_WMV9D_CORRUPTED_BITS=51,    /* Error bit stream                       */
+    E_WMV9D_FAILED,               /* Failure                                */
+    E_WMV9D_UNSUPPORTED,          /* Unsupported format                     */
+    E_WMV9D_NO_KEYFRAME_DECODED,  /* first frame is not an I frame          */
+    E_WMV9D_SIZE_NOT_FOUND,       /* Frame size not found in bit stream     */
+    E_WMV9D_NOT_INITIALIZED,      /* Decoder is not initialized             */
+    E_WMV9D_INVALID_ARGUMENTS,     /* Argument to the API is invalid         */
+    E_WMV9D_SET_CB_OK,            /*!< Decoder Register call back OK       */
+    E_WMV9D_SET_CB_FAIL           /*!< Decoder Register call back FAIL       */
+} eWmv9DecRetType;
+
+
+/*
+ * Memory alignment types enumeration.
+ */
+
+typedef enum
+{
+    E_WMV9D_ALIGN_NONE = 0,       /* buffer can start at any place          */
+    E_WMV9D_ALIGN_HALF_WORD,      /* address's last bit has to be 0         */
+    E_WMV9D_ALIGN_WORD,           /* address's last 2 bits has to be 0      */
+    E_WMV9D_ALIGN_DWORD,          /* address's last 3 bits has to be 0      */
+    E_WMV9D_ALIGN_QWORD,          /* address's last 4 bits has to be 0      */
+    E_WMV9D_ALIGN_OCTAWORD        /* address's last 5 bits has to be 0      */
+} eWmv9DecMemAlignType;
+
+
+/*
+ * Type of the VOP decoded last.
+ */
+
+typedef enum
+{
+    E_WMV9D_INTRA_VOP,           /* Intra VOP or I-VOP	                    */
+    E_WMV9D_INTER_VOP,           /* Inter VOP or P-VOP	                    */
+    E_WMV9D_BIDIR_VOP,           /* Bidirectional VOP or B-VOP              */
+    E_WMV9D_UNKNOWN_VOP,         /* Unknown, should not happen              */
+} eWmv9DecVOPType;
+
+
+/*
+ * Defines the encoding bitstream. It does not cover all of the possible asf
+ * string. Use the converter function to convert the asf string to this type,
+ * in case multiple types are supported by same application. Otherwise (only
+ * one format is guranteed at the input) application can use the corresponding
+ * value directly, without trying to use asf format string.
+ */
+
+typedef enum
+{
+    E_WMV9D_COMP_FMT_WMV9,       /* WMV9 encoded bitstream                  */
+    E_WMV9D_COMP_FMT_WMV8,       /* WMV8 encoded bitstream                  */
+    E_WMV9D_COMP_FMT_WMV7,       /* WMV7 encoded bitstream                  */
+    E_WMV9D_COMP_FMT_UNSUPPORTED /* Unsupported encoded bitstream           */
+} eWmv9DecCompFmtType;
+
+
+/************ Decoder data structures ***********/
+
+/* Data structure to define each memory block request */
+
+typedef struct
+{
+    WMV9D_S32            s32Size;     /* Current size requirement            */
+    WMV9D_S32            s32MemType;  /* Memory type description             */
+    WMV9D_S32            s32Priority; /* determines impact on the performance */
+    eWmv9DecMemAlignType eMemAlign;   /* Memory alignment of the buffer      */
+    WMV9D_S32            s32OldSize;  /* Old size, in case being reallocated */
+    WMV9D_S32            s32MaxSize;  /* Maximum size that can be asked for  */
+    WMV9D_Void*          pvUnalignedBuffer;  /* unaligned buffer pointer     */
+    WMV9D_Void*          pvBuffer;    /* buffer start address with alignment */
+} sWmv9DecMemBlockType;
+
+
+/*ENGR40526_START
+* Data structure to hold output buffer information
+*/
+
+typedef struct
+{
+	WMV9D_S32	s32CropLeft; /* Crop size on left */
+	WMV9D_S32	s32CropRight; /* Crop size on right */
+	WMV9D_S32	s32CropTop; /* Crop size at top */
+	WMV9D_S32	s32CropBottom; /* Crop size at bottom */
+	WMV9D_U32	u32NumBuffers; /* Number of output buffers */
+} sWmv9DecOutputInfo;
+/*ENGR40526_END*/
+
+/*
+ * Data structure to define the complete memmory requests
+ */
+
+typedef struct
+{
+    WMV9D_S32             s32NumReqs;  /* Number of valid requests           */
+    sWmv9DecMemBlockType  asMemBlks[WMV9D_MAX_NUM_MEM_REQS]; /* requests     */
+/*ENGR40526_START*/
+    sWmv9DecOutputInfo    sOutputInfo; /*output buffer information*/
+/*ENGR40526_END*/
+    WMV9D_S32             s32MinFrameBufferNum;  /*!< minimum number of frame buffer MAD ShangHai*/
+} sWmv9DecMemAllocInfoType;
+
+
+/*Added to support UYVY and IYUV and IYUV padded data*/
+
+typedef enum tagVideoFormat_WMC
+{
+    IYUV_WMV=0,
+
+ //   #ifdef OUTPUT_BUFFER_CHANGES
+    IYUV_WMV_PADDED,
+ //   #endif
+
+  //  #ifndef WMV9_SIMPLE_ONLY
+    UYVY_WMV
+  //  #endif
+
+} tVideoFormat_WMC;
+
+
+
+/*
+ * Structure to hold the decoded frame information.
+ * Please note that currently the row size for Cb and Cr contains same value
+ */
+
+typedef struct
+{
+    WMV9D_U8* pu8YBuf;      /* Y component data buffer start address  */
+    WMV9D_U8* pu8CbBuf;     /* Cb component data buffer start address */
+    WMV9D_U8* pu8CrBuf;     /* Cr component data buffer start address */
+
+    WMV9D_S32       s32YRowSize;  /* Row size of Y data buffer  (padded width Luma)            */
+    WMV9D_S32       s32CbRowSize; /* Row size of Cb data buffer (padded width Chroma)          */
+    WMV9D_S32       s32CrRowSize; /* Row size of Cr data buffer (padded width Chroma)          */
+//    #ifdef OUTPUT_BUFFER_CHANGES
+    tVideoFormat_WMC tOutputFormat;
+//    #endif
+} sWmv9DecYCbCrBufferType;
+
+
+/*
+ * Structure to hold the parameters that are passed from application to
+ * decoder and vice versa. Frame rate and bitrate, though set by application
+ * initialy, can be corrected by decoder while initilizing.
+ */
+
+typedef struct
+{
+    sWmv9DecYCbCrBufferType sOutputBuffer;      /* decoded frame information */
+    eWmv9DecCompFmtType     eCompressionFormat; /* encoding format info      */
+    WMV9D_S32               s32FrameRate;       /* Frame rate in fps         */
+    WMV9D_S32               s32BitRate;         /* Bit rate in bps           */
+    WMV9D_U16               u16FrameWidth;      /* Frame width in pixels     */
+    WMV9D_U16               u16FrameHeight;     /* Frame hight in pixels     */
+    WMV9D_U32               u32PrevFrameNum;    /* Please see the API doc    */
+    WMV9D_U32               u32CurrFrameNum;    /* Last decoded frame number */
+    eWmv9DecVOPType         eVopType;           /* Last decoded frame's type */
+} sWmv9DecParamsType;
+
+typedef enum
+{
+    E_RELEASE_FRAME =0,
+    E_REJECT_FRAME,
+    E_GET_FRAME
+} eWmv9CallbackType; //add this to indicate additional callback function type.
+//add a API function to register additional callback function
+
+/**************************************************
+ * Direct rendering type and data structure
+ **************************************************/
+typedef void* (*bufferGetter)(void* /*pvAppContext*/);
+typedef void (*bufferRejecter)(void* /*mem_ptr*/, void* /*pvAppContext*/);
+typedef void (*bufferReleaser)(void* /*mem_ptr*/, void* /*pvAppContext*/);
+//typedef void* (*bufferGetter)(void);
+//typedef void (*bufferRejecter)(void* /*mem_ptr*/);
+
+typedef struct _WMV9D_FrameManager
+{
+    bufferGetter BfGetter;
+    bufferRejecter BfRejector;
+}WMV9D_FrameManager;
+
+/*
+ * Main WMV9 decoder object. This is used in all decoder API.
+ */
+
+typedef struct
+{
+    sWmv9DecMemAllocInfoType sMemInfo;     /* memory requirements            */
+    sWmv9DecParamsType       sDecParam;    /* sequence/frame paramters       */
+    WMV9D_Void*              pvWmv9Obj;    /* internal decoder object        */
+    WMV9D_Void*              pvBitBuffer;  /* buffer for bitstream           */
+    WMV9D_Void*              pvAppContext; /* application context for cbk    */
+    FpWmv9DecReadCbkType     pfCbkBuffRead;/* Callback function pointer      */
+	WMV9D_FrameManager		 frameManager; /* MAD Shanghai Add for Direct Rendering*/
+} sWmv9DecObjectType;
+
+//#ifdef __SYMBIAN32__
+//#define IMPORT_C __declspec(dllimport)
+//#define EXPORT_C __declspec(dllexport)
+//#else
+#define IMPORT_C
+#define EXPORT_C
+//#endif
+
+
+/************  function definitions *****************/
+
+/* Small utility functions, helpful to the application */
+
+/*
+ * Returns the compression format type used in API, given the ASF file
+ * compression format string. Right now, only WMV[123] strings are supported.
+ * For the rest types, it returns unsupported format type.
+ */
+
+IMPORT_C eWmv9DecCompFmtType eWMV9DCompFormat (const WMV9D_U8* format);
+
+
+/***********  main API functions **********/
+
+/*
+ * Query for the memory requirement, given width and height of frame
+ * The decoder sets the Meminfo structure with the required memory buffer
+ * requests.
+ * TODO : The object already has width and height, do we need to pass
+ *        it separately ?
+ */
+
+IMPORT_C eWmv9DecRetType eWMV9DQuerymem (sWmv9DecObjectType* psWmv9Obj,
+                                WMV9D_S32 s32Height, WMV9D_S32 s32Width);
+
+
+
+/*
+ * Initialise the decoder object and parses the sequence header, if required.
+ * The memory requested should be met and the buffer pointers are provided.
+ * Decoder, after actual initialization, parses the sequence header and sets
+ * few decoder parameters (like frame rate, bitrate). It can potentially call
+ * the callback function, so set the function callback before calling API.
+ */
+
+IMPORT_C eWmv9DecRetType eWMV9DInit (sWmv9DecObjectType* psWmv9DecObj);
+
+
+
+/*
+ * Decode one frame from the bitstream,
+ * This function gets the data using the callback function, so make sure that
+ * it is properly set. The decoded data will be available as read only in the
+ * output frame buffer structure. If no frames has been skipped, the
+ * u32CurFrameNumber will provide the frame number for this frame.
+ */
+
+IMPORT_C eWmv9DecRetType eWMV9DDecode (sWmv9DecObjectType* psWmv9Obj,
+                              WMV9D_U32 u32FrameDataSize);
+
+typedef eWmv9DecRetType ( *WMV9DecodeFunc) (sWmv9DecObjectType* psWmv9Obj,
+                              WMV9D_U32 u32FrameDataSize);
+
+
+
+
+/*
+ * Free the decoder structure (mainly reset the decoder internals)
+ */
+
+IMPORT_C eWmv9DecRetType eWMV9DFree (sWmv9DecObjectType *psWmv9Obj);
+
+//#ifdef OUTPUT_BUFFER_CHANGES
+/*! API to get the output frame*/
+eWmv9DecRetType  eWMV9DecGetOutputFrame (sWmv9DecObjectType *psWmv9Obj);
+//#endif
+
+
+//#if SKIP_ENABLE//ENGR38817
+
+/*
+ * API to enable the 'skip to next I VOP mode' of the decoder
+ */
+
+eWmv9DecRetType  eWMV9DEnableSkipMode  (sWmv9DecObjectType *psWmv9Obj);
+
+
+//#endif
+
+eWmv9DecRetType  eWMV9DEnableSkipBMode(sWmv9DecObjectType * psWmv9Obj,int enableflag);
+
+/**************************************************
+ * Direct rendering API functions
+ **************************************************/
+/*! \brief
+ *        Set the Frame manager to decoder
+ */
+extern void WMV9DSetBufferManager (sWmv9DecObjectType *psWmv9Obj, WMV9D_FrameManager* manager);
+extern eWmv9DecRetType eWMV9DSetAdditionalCallbackFunction (sWmv9DecObjectType *psWmv9Obj, eWmv9CallbackType funcType, void* cbFunc);
+extern const char * WMV9DCodecVersionInfo();
+#ifdef __cplusplus
+}
+#endif
+#endif /* WMV9_DEC_API_H  */
--- /dev/null
+++ gst-fsl-plugins-3.0.7/inc/core_lib/mpeg2_dec_api.h
@@ -0,0 +1,267 @@
+/*
+ * Copyright (c) 2005-2010, 2013 Freescale Semiconductor, Inc.
+ */
+
+/*
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef DECODERINTERFACE_H
+#define DECODERINTERFACE_H
+
+#include "render_type.h"
+/*****************************************************************************
+*  File Description:   Contains header info for decoder interface.
+*
+*    DD/MMM/YYYY   Code Ver      Description                 Author
+*    -----------   --------      -----------              ------------
+*    12/Jun/2006       01           Created       			MANOJ ARVIND & DURGAPRASAD S. BILAGI
+*    07/Nov/2007      02           add memory type		Eagle Zhou
+*                    				(ENGR00056087)
+*    09/Nov/2007      03           DR(ENGR00055417)        Wang Zening
+*    11/Aug/2009      04           ENGR00115078              Eagle Zhou: add dropping B frames
+*******************************************************************************
+*
+*/
+
+
+#define MAX_NUM_MEM_REQS 30         /*! Maximum Number of MEM Requests  */
+
+/*! defines to specify type of memory. Only one of the two in each group
+ * (speed and usage) shall be on but not both.
+ */
+#define E_AVCD_SLOW_MEMORY       0x1   /*! slower memory is acceptable */
+#define E_AVCD_FAST_MEMORY       0x2   /*! faster memory is preferable */
+#define E_AVCD_STATIC_MEMORY     0x4   /*! content is used over API calls */
+#define E_AVCD_SCRATCH_MEMORY    0x8   /*! content is not used over
+                                             successessive Decode API calls */
+
+/*! retrieve the type of memory */
+
+#define AVCD_IS_FAST_MEMORY(memType)    (memType & E_AVCD_FAST_MEMORY)
+#define AVCD_IS_SLOW_MEMORY(memType)    (memType & E_AVCD_SLOW_MEMORY)
+#define AVCD_IS_STATIC_MEMORY(memType)  (memType & E_AVCD_STATIC_MEMORY)
+#define AVCD_IS_SCRATCH_MEMORY(memType) (memType & E_AVCD_SCRATCH_MEMORY)
+
+
+/*! All the API return one of the following */
+
+typedef enum
+{
+    /* Successfull return values */
+    E_MPEG2D_SUCCESS = 0,         /*!< Success                             */
+    E_MPEG2D_PARTIAL_DECODE,
+    E_MPEG2D_ENDOF_BITSTREAM,     /*!< End of Bit Stream                   */
+    E_MPEG2D_FRAME_READY,
+    E_MPEG2D_FRAME_SKIPPED,
+    /* Successful return with warning, decoding can continue */
+    /* Start with number 11 */
+
+    /* recoverable error return, correct the situation and continue */
+    E_MPEG2D_NOT_ENOUGH_BITS = 31,/*!< Not enough bits are provided        */
+    E_MPEG2D_OUT_OF_MEMORY,       /*!< Out of Memory                       */
+    E_MPEG2D_WRONG_ALIGNMENT,     /*!< Incorrect Memory alignment          */
+    E_MPEG2D_SIZE_CHANGED,        /*!< Image size changed                  */
+    E_MPEG2D_INVALID_ARGUMENTS,   /*!< API arguments are invalid           */
+    E_MPEG2D_DEMO_PROTECT,         /* the output is corrupted by demo protection    */
+
+    /* irrecoverable error type */
+    E_MPEG2D_ERROR_STREAM = 51,   /*!< Errored Bitstream                   */
+    E_MPEG2D_FAILURE,             /*!< Failure                             */
+    E_MPEG2D_UNSUPPORTED,         /*!< Unsupported Format                  */
+    E_MPEG2D_NO_IFRAME,           /*!< MPEG2D_first frame is not an I frame       */
+    E_MPEG2D_SIZE_NOT_FOUND,      /*!< Frame size not found in bitstream   */
+    E_MPEG2D_NOT_INITIALIZED      /*!< Decoder Not Initialised             */
+
+} eMpeg2DecRetType;
+
+
+/*! \enum Specifies the current functional state of the Decoder */
+typedef enum
+{
+    E_MPEG2D_INVALID = 0,        /*!< Invalid Decoder State */
+    E_MPEG2D_PLAY,               /*!< Decoder is decoding frames */
+    E_MPEG2D_FF,                 /*!< Decoder is skipping frames */
+    E_MPEG2D_REW                 /*!< Decoder is skipping frames in a direction
+                                      opposite to PLAY and FF. Current Decoder
+                                      doesn't support REW feature */
+} eDecodeState;
+
+/*! \enum Enumeration of possible buffer alignment */
+typedef enum
+{
+    E_MPEG2D_ALIGN_NONE = 0,  /*!< buffer can start at any place           */
+    E_MPEG2D_ALIGN_HALF_WORD, /*!< start address's last bit has to be 0    */
+    E_MPEG2D_ALIGN_WORD       /*!< start adresse's last 2 bits has to be 0 */
+} eMpeg2DecMemAlignType;
+
+
+/**************************************************
+ * Direct rendering type and data structure
+ **************************************************/
+//typedef void* (*bufferGetter)(void* /*pvAppContext*/);
+//typedef void (*bufferRejecter)(void* /*mem_ptr*/, void* /*pvAppContext*/);
+
+typedef struct _MPEG2D_FrameManager
+{
+    bufferGetter BfGetter;
+    bufferRejecter BfRejector;
+}MPEG2D_FrameManager;
+
+/*! Different structure definitions */
+
+/*! structure for Y Cb Cr output from the decoder. */
+typedef struct
+{
+    unsigned char   *pu8YBuf;     /*!< Y Buf       */
+    int             s32YBufLen;   /*!< Y Buf Len   */
+} sMpeg2DecYCbCrBuffer;
+
+
+/*! Structure to hold each memory block requests from the decoder.
+ *  The size and alignment are must to meet criteria, whereas others
+ *  help to achive the performance projected.
+ */
+
+typedef struct
+{
+    int 	s32Size;         /*!< size of the memory block            */
+    int 	s32Type;         /*!< type of the memory - slow/fast and
+                                  static/scratch                      */
+    int     s32Priority;     /*!< how important the block is          */
+    int 	s32Align;        /*!< alignment of the memory block       */
+    void 	*pvBuffer;       /*!< pointer to allocated memory buffer  */
+} sMpeg2DecMemBlock;
+
+
+/*! Structure to hold all the memory requests from the decoder  */
+
+typedef struct
+{
+    int               s32NumReqs;                   /*!< Number of blocks  */
+	int 			  s32BlkNum ;					/*!< block number  */
+    sMpeg2DecMemBlock asMemBlks[MAX_NUM_MEM_REQS];  /*!< array of requests */
+    int               s32MinFrameBufferNum;  /*!< minimum number of frame buffer*/
+} sMpeg2DecMemAllocInfo;
+
+
+/*! Structure for defining the decoder output. */
+typedef struct
+{
+    sMpeg2DecYCbCrBuffer sOutputBuffer;           /*!< Decoded frame      */
+    signed char         *p8MbQuants;              /*!< Quant values       */       //ask
+    unsigned short int 	 u16FrameWidth;           /*!< FrameWidth         */
+    unsigned short int 	 u16FrameHeight;          /*!< FrameHeight        */
+    unsigned int         bitrate;                 /*!< Bitrate			  */
+
+
+} sMpeg2DecoderParams;
+
+
+
+/*! This structure defines the decoder context. All the decoder API
+ *  needs this structure as one of its argument.
+ */
+typedef struct
+{
+    sMpeg2DecMemAllocInfo   sMemInfo;      /*!< memory requirements info */
+    sMpeg2DecoderParams     sDecParam;     /*!< decoder parameters       */
+    void                    *pvMpeg2Obj;   /*!< decoder library object   */
+    void                    *pvAppContext; /*!< Anything app specific    */
+    eDecodeState            eState;        /*!< Indicates current Decoder
+                                                State */
+	/*Added for call back changes*/
+
+    int (* ptr_cbkMPEG2DBufRead) (int *, unsigned char **, int , void *);
+
+    /*Added for call back changes*/
+
+
+} sMpeg2DecObject;
+
+
+
+//Function Declarations
+#ifdef __cplusplus
+#define EXTERN extern "C"
+#else
+#define EXTERN
+#endif
+
+/*! Function to query memory requrement of the decoder */
+EXTERN eMpeg2DecRetType  eMPEG2DQuerymem(sMpeg2DecObject *psMp2Obj);
+
+/*! Function to query memory requrement of the decoder */
+EXTERN eMpeg2DecRetType  eMPEG2D_Re_Querymem(sMpeg2DecObject *psMp2Obj);
+
+/*! Function to initialize the decoder */
+EXTERN eMpeg2DecRetType  eMPEG2D_Init (sMpeg2DecObject *psMp2Obj);
+
+/*! API to decode single frame of the encoded bitstream */
+EXTERN eMpeg2DecRetType eMPEG2Decode(sMpeg2DecObject *psMp2Obj,unsigned int *s32decodedBytes, void *pvAppContext);
+
+/*! Function to free the resources allocated by decoder, if any */
+EXTERN eMpeg2DecRetType  eMPEG2DFree (sMpeg2DecObject *psMp2Obj);
+
+
+EXTERN eMpeg2DecRetType  eMPEG2D_ReInit (sMpeg2DecObject *psMp2Obj);
+
+/*! \brief
+ * Call back function for reading the input buffer by the decoder.
+ *
+ * Whenver the internul buffer inside the decoder is empty, the decoder will
+ * call this function, passing the application context also. The application
+ * shall implement a function to provide the required portion of the bitstream
+ * of the given size, starting at the given offset in the provided buffer.
+ */
+EXTERN  int cbkMPEG2DBufRead (int *s32BufLen, unsigned char **pu8Buf,
+                             int s32Offset, void *pvAppContext);
+
+/*Added for call back by changes*/
+
+EXTERN void Mpeg2_register_func(sMpeg2DecObject *,int (*) (int *, unsigned char **, int , void *));
+
+/*Added to call back by changes*/
+/**************************************************
+ * Direct rendering API functions
+ **************************************************/
+/*! \brief
+ *        Set the Frame manager to decoder,should be invoked after App invoked eMPEG2D_Init
+ */
+EXTERN void MPEG2DSetBufferManager (sMpeg2DecObject *psMp2Obj, MPEG2D_FrameManager* manager);
+
+
+// new api format to support additional callback such as release,...
+//typedef void (*bufferReleaser)(void* /*mem_ptr*/, void* /*pvAppContext*/);
+//typedef enum
+//{
+//	E_GET_FRAME =0,
+//	E_REJECT_FRAME,
+//	E_RELEASE_FRAME,
+//} eCallbackType; //add this to indicate additional callback function type.
+
+//typedef enum
+//{
+//	E_CB_SET_OK =0,
+//	E_CB_SET_FAIL,
+//} eCallbackSetRet; //add this to indicate additional callback function type.
+
+EXTERN eCallbackSetRet MPEG2DSetAdditionalCallbackFunction (sMpeg2DecObject *psMp2Obj, eCallbackType funcType, void* cbFunc);
+
+EXTERN const char * MPEG2DCodecVersionInfo();
+
+EXTERN eMpeg2DecRetType MPEG2DEnableSkipBMode(sMpeg2DecObject *psMp2Obj,int enableflag);
+
+#endif  /* ifndef DECODERINTERFACE_H */
--- /dev/null
+++ gst-fsl-plugins-3.0.7/inc/core_lib/deinterlace_api.h
@@ -0,0 +1,173 @@
+
+/*
+* Copyright (c) 2011-2013, Freescale Semiconductor, Inc. 
+ */
+
+/*
+* This library is free software; you can redistribute it and/or
+* modify it under the terms of the GNU Lesser General Public
+* License as published by the Free Software Foundation; either
+* version 2.1 of the License, or (at your option) any later version.
+*
+* This library is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* Lesser General Public License for more details.
+*
+* You should have received a copy of the GNU Lesser General Public
+* License along with this library; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+/*!
+ ***********************************************************************
+ * Header file of Freescale deinterlace algoritm
+ *
+ *
+ * History
+ *   Date          Changed                                Changed by
+ *   Dec. 04, 2007 Create                                 Zhenyong Chen
+ *   Jan. 30, 2008 Add API DeinterlacerGetVersion         Zhenyong Chen
+ *   Jun  26, 2008 Change version string API              Zhenyong Chen
+ ***********************************************************************
+ */
+
+
+#ifndef __DEINTERLACE_API_H__
+#define __DEINTERLACE_API_H__
+
+#ifdef __cplusplus 
+extern "C" { 
+#endif 
+
+
+// Chroma format
+#define CHROM_FMT_420   0
+#define CHROM_FMT_422   1
+#define CHROM_FMT_444   2
+
+// Deinterlace methods - predefined methods
+#define DEINTMETHOD_BOB      0
+#define DEINTMETHOD_WEAVE    1
+
+
+/* Methods in this collection
+ */
+#define SAFE_BASE          2000
+#define DEINTMETHOD_BLOCK_VT_NEW_FIELDSAD_BOB     (SAFE_BASE+2)
+#define DEINTMETHOD_BLOCK_VT_NEW_FRAMESAD_BOB     (SAFE_BASE+3)
+#define DEINTMETHOD_BLOCK_VT_NEW_FIELDSAD_4TAP    (SAFE_BASE+4)
+#define DEINTMETHOD_BLOCK_VT_NEW_FRAMESAD_4TAP    (SAFE_BASE+5)
+#define DEINTMETHOD_BLOCK_VT_GROUP_FRAMESAD_4TAP  (SAFE_BASE+6)
+#define DEINTMETHOD_BLOCK_VT_GROUP_FRAMESAD_BOB   (SAFE_BASE+7)
+
+
+// Attribute
+typedef struct tagDeintMethod
+{
+    unsigned int method;  // ID of method
+    char name[64];        // Name of method
+    char need_prev_frame; // Whether previous frame is needed for reference
+    char need_next_frame; // Whether next frame is needed for reference
+    char safe;            // Safety for use of this method
+}DEINTMETHOD;
+
+typedef struct tagPICTURE
+{
+    BYTE *y;
+    BYTE *cb;
+    BYTE *cr;
+}PICTURE;
+
+typedef struct tagDEINTER
+{
+    // Frame buffers
+    PICTURE frame[3]; // frame[0]: prevous frame; frame[1]: current frame; frame[2]: next frame
+    // Parameter of luma/chroma stride
+    int y_stride;
+    int uv_stride;
+    // Chroma format. 4:2:0 (0), 4:2:2 (1), 4:4:4 (2) support.
+    int chrom_fmt;
+    // Parameter of picture size (in pixel)
+    int width;
+    int height;
+    // Which field is first
+    BOOL top_first;
+    // How to deinterlace
+    int method;
+    // Research usage, a way to let outside control deinterlacing process. Set NULL
+    void *dynamic_params;
+}DEINTER;
+
+/* \Function
+ *   InitDeinterlaceSafe
+ * \Brief
+ *   Init deinterlace algorithm, and get information of implemented 
+ *   algorithms
+ * \Return value
+ *   None
+ * \Parameters
+ *   pMethods   [out] Buffer to store information
+ *   count      [out] Count of methods implemented
+ * \See also
+ *   N/A
+ */
+void InitDeinterlaceSafe(DEINTMETHOD *pMethods, int *count);
+
+/* \Function
+ *   DeinterlaceSafe
+ * \Brief
+ *   Core function to deinterlace an interlace frame, and output a  
+ *   progressive frame in same place as current frame
+ * \Return value
+ *   None
+ * \Parameters
+ *   pDeinterInfo  [inout] See definition of DEINTER
+ * \See also
+ *   Document ...
+ */
+void DeinterlaceSafe(DEINTER *pDeinterInfo);
+
+/* \Function
+ *   IsFrameReusableSafe
+ * \Brief
+ *   To determine current frame buffer can be reused when requres reloading
+ * \Return value
+ *   1  - reusable
+ *   0  - not reusable
+ *   -1 - undetermined
+ * \Parameters
+ *   nMethod    [in] Deinterlace method
+ *   bDrawTrack [in] Whether tracking motion block is enabled. When this 
+ *                   feature is enabled, frame buffer will be overwritten 
+ *                   to show block edge
+ * \Remark
+ *   For somet deinterlace algorithms, current frame after filtering can 
+ *   be reused for another frame deinterlacing (next frame, current frame, 
+ *   or previous frame). To avoid reloading it, use this API to check whether
+ *   whether current frame need (or not) reload.
+ *
+ * \See also
+ *   N/A
+ */
+int  IsFrameReusableSafe(int nMethod, BOOL bDrawTrack);
+
+/*
+ * Get version description
+ *
+ * Parameters
+ *   None
+ *
+ * Return value
+ *   ASCII string describing version information. Details see
+ *   api document
+ */
+const char * GetDeinterlaceVersionInfo();
+
+
+#ifdef __cplusplus 
+} 
+#endif 
+
+#endif /* __DEINTERLACE_API_H__ */
+
--- /dev/null
+++ gst-fsl-plugins-3.0.7/inc/core_lib/wbamr_enc_interface.h
@@ -0,0 +1,148 @@
+
+/*
+* Copyright (c) 2004-2010, 2013, Freescale Semiconductor, Inc. 
+*/
+
+/*
+* This library is free software; you can redistribute it and/or
+* modify it under the terms of the GNU Lesser General Public
+* License as published by the Free Software Foundation; either
+* version 2.1 of the License, or (at your option) any later version.
+*
+* This library is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* Lesser General Public License for more details.
+*
+* You should have received a copy of the GNU Lesser General Public
+* License along with this library; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+/************************************************************************
+* File Name			: WBAMR_ENC_INTERFACE.H
+*
+* Description		: WBAMR Encoder interface header.
+*
+* Functions Included: --NONE--
+*
+****************************** Change History**************************
+*
+*    DD/MM/YYYY     Code Ver     Description      Author
+*    -----------     --------     -----------      ------
+*	 27/10/2004		1.0			Initial version		Shashi/Naganna
+**********************************************************************/
+
+
+#ifndef _WBAMR_ENC_INTERFACE_H_
+#define	_WBAMR_ENC_INTERFACE_H_
+
+#include "wbamr_common_interface.h"
+
+/* this should be set to 0xF to enable all the debug level logs
+ * value of 0x1 will enbale - log level 1 only
+ * value of 0x2 will enable - log level 2 only
+ * value of 0x3 will enable - level 1 and 2 logs
+ * value of 0x4 will enable - level 3 logs
+ * value of 0x8 will enabel - level 4 log
+ */
+#define WBAMRE_DEBUG_LVL 0x0
+
+/* this is start of log message */
+#define WBAMRE_BEGIN_DBG_MSGID   0
+/* end of debug msg id */
+#define WBAMRE_END_DBG_MSGID     199
+
+/* for future use */
+#define BEGIN_WBAMRE_DATA		NULL /* to be decided by application */
+
+#define WBAMRE_NUM_WARNING	  20
+#define WBAMRE_NUM_RECOVERROR 20
+#define WBAMRE_WARNING_BASE   11
+#define WBAMRE_RECOVERROR_BASE (WBAMRE_NUM_WARNING+WBAMRE_WARNING_BASE)
+#define WBAMRE_FATALERROR_BASE (WBAMRE_RECOVERROR_BASE+WBAMRE_NUM_RECOVERROR)
+
+
+/***** Encoder return type, other return value to be added ****/
+/* Success is assigned to 0. As of now there can be 20 warnings, starting from 11 to 30.
+Recoverable errors can be 20, starting from 31 to 50. Fatal errors can be 20, starting from 51 to 70. Later more error types can be added */
+
+typedef enum
+{
+     WBAMRE_OK,
+     WBAMRE_WARNING = WBAMRE_WARNING_BASE,			/* Warning */
+     WBAMRE_INVALID_MODE = WBAMRE_RECOVERROR_BASE,	/* Recoverable error */
+     WBAMRE_INIT_ERROR,								/* Recoverable error */
+     WBAMRE_MEMALLOC_ERROR = WBAMRE_FATALERROR_BASE/* Fatal error */
+
+} WBAMRE_RET_TYPE;
+
+													/* transmitted speech frame enum */
+typedef enum
+{
+	 WBAMRE_TX_SPEECH = 0,
+     WBAMRE_TX_SID_FIRST,
+     WBAMRE_TX_SID_UPDATE,
+     WBAMRE_TX_NO_DATA,
+     WBAMRE_TX_N_FRAMETYPES							/* number of frame types */
+} WBAMRE_TXFrameType;
+
+/****************** Structure/Union ******************/
+
+typedef struct
+{
+	WBAMR_S32		wbamre_size;					/* Size in bytes */
+	WBAMRMemType	wbamre_mem_type;				/* Static or scratch */
+	WBAMR_S32 		wbamre_type_fs;					/* Fast or Slow */
+	WBAMR_U8		wbamre_priority;				/* Priority level */
+	void			*wbappe_base_ptr;				/* Pointer to the base memory, which will be
+														allocated and filled by the application*/
+} WBAMRE_Mem_Alloc_Info_Sub;
+
+													/*Memory information structure array*/
+typedef struct
+{
+	WBAMR_S32					wbamre_num_reqs;	/* Number of valid memory requests */
+	WBAMRE_Mem_Alloc_Info_Sub 	mem_info_sub[WBAMR_MAX_NUM_MEM_REQS];
+} WBAMRE_Mem_Alloc_Info;
+
+
+													/* encoder parameter structure */
+typedef struct
+{
+	WBAMRE_Mem_Alloc_Info	wbamre_mem_info;
+	void				    *wbamre_encode_info_struct_ptr;
+    WBAMR_U8                *wbappe_initialized_data_start;
+	WBAMR_S32				wbappe_dtx_flag;
+	WBAMR_S16				*wbappe_mode;
+	WBAMR_U16				*wbamre_output_size;
+	WBAMR_U8				wbamre_output_format;
+	WBAMR_U8               watermarkFlag;
+} WBAMRE_Encoder_Config;
+
+
+/* c prototypes */
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+ WBAMRE_RET_TYPE wbamre_query_enc_mem(
+				WBAMRE_Encoder_Config *enc_config);
+
+ WBAMRE_RET_TYPE wbamre_encode_init(
+				WBAMRE_Encoder_Config *enc_config);
+
+ WBAMRE_RET_TYPE wbamre_encode_frame (
+				WBAMRE_Encoder_Config *enc_config,
+				WBAMR_S16 *in_buf,
+				WBAMR_S16 *out_buf);
+ const char *WBAMR_get_version_info(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
--- /dev/null
+++ gst-fsl-plugins-3.0.7/inc/core_lib/downmix_dec_interface.h
@@ -0,0 +1,123 @@
+
+/*
+* Copyright (c) 2005-2010, 2013 Freescale Semiconductor, Inc. 
+ */
+
+/*
+* This library is free software; you can redistribute it and/or
+* modify it under the terms of the GNU Lesser General Public
+* License as published by the Free Software Foundation; either
+* version 2.1 of the License, or (at your option) any later version.
+*
+* This library is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* Lesser General Public License for more details.
+*
+* You should have received a copy of the GNU Lesser General Public
+* License along with this library; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+ 
+/**************************** Change History ***********************************
+ *
+ *   DD/MM/YYYY Code Ver     Description                        Author
+ *   --------   -------      -----------                        ------
+ *   16/10/2007 0.0          create                             Guoyin Chen
+ *
+ ******************************************************************************/
+
+#ifndef __DM_DEC_INTERFACE_H__
+#define __DM_DEC_INTERFACE_H__
+
+#include "ppp_interface.h"
+
+#ifndef __cplusplus
+#define DM_EXTERN_API extern
+#else
+#define DM_EXTERN_API extern "C"
+#endif
+
+#define DM_MAX_NUM_MEM_REQS 2
+#define DM_FAST_MEMORY        0
+#define DM_SLOW_MEMORY        1
+
+/* Data type */
+typedef unsigned char     DM_UINT8;
+typedef char                   DM_INT8;
+typedef unsigned short    DM_UINT16;
+typedef short                  DM_INT16;
+typedef unsigned int        DM_UINT32;
+typedef int                      DM_INT32;
+
+typedef enum
+{
+    DM_OK = 0,
+    DM_ERROR_INVALIDARG,
+    DM_ERROR_NOMEMORY,
+    DM_ERROR_NOTSUPPORTED,
+    DM_ERROR_NOENOUGH_OUTPUT,
+    DM_ERROR_INIT,
+    DM_ERROR_EOF
+}DM_RET_TYPE;
+
+typedef enum
+{
+    DM_MEM_SCRATCH = 0,
+    DM_MEM_PERSISTENT
+}DM_MEM_DESC;
+
+typedef enum
+{
+	DM_MEM_PRIORITY_HIGH = 0,
+	DM_MEM_PRIORITY_LOW
+}DM_MEM_PRIORITY;
+
+typedef struct {
+	DM_INT32           		dm_size;     /* Size in bytes */
+	DM_INT32 	     		dm_type;	   /* Memory type Fast or Slow */
+	DM_MEM_DESC   		dm_mem_desc; /* to indicate if it is scratch memory */
+	DM_MEM_PRIORITY       dm_priority; /* In case of fast memory, specify the priority */
+	void 	            		*app_base_ptr; /* Pointer to the base memory , which will be allocated and
+                                    * filled by the  application */
+}DM_Mem_Alloc_Info_Sub;
+
+typedef struct {
+    DM_INT32         dm_num_reqs;    /*  Number of valid memory requests */
+    DM_Mem_Alloc_Info_Sub mem_info_sub[DM_MAX_NUM_MEM_REQS];
+}DM_Mem_Alloc_Info;
+
+typedef void* DM_HANDLE;
+
+typedef struct DM_Dec_Config {
+       DM_Mem_Alloc_Info	        dm_mem_info;
+       DM_HANDLE                    h_dm_decoder;
+       DM_UINT32		            app_instance_id;
+       DM_INT32             		dm_input_channels;
+       DM_INT32             		dm_input_ch_mask;
+       DM_INT32                     dm_input_bitwidth;
+       DM_INT32                     dm_input_bitdepth;
+       DM_INT32				        dm_input_low24bit;	/* flag of low 24 bit, only for 24 bit input*/
+       DM_INT32             		dm_output_channels;
+       DM_INT32             		dm_output_ch_mask;
+       DM_INT32                     dm_output_bitwidth;
+       DM_INT32                     dm_output_bitdepth;
+       DM_INT32				        dm_output_low24bit;	/* flag of low 24 bit, only for 24 bit output*/
+       DM_INT32             		dm_input_freq;
+       DM_INT32             		WMflag;
+} DM_Decode_Config;
+
+DM_EXTERN_API DM_UINT32 dm_default_channel_mask(DM_UINT32 nChannels);
+
+DM_EXTERN_API DM_RET_TYPE dm_query_dec_mem (DM_Decode_Config * dec_config);
+
+DM_EXTERN_API DM_RET_TYPE dm_decode_init (DM_Decode_Config *dec_config);
+
+DM_EXTERN_API DM_RET_TYPE dm_decode_frame (DM_Decode_Config *dec_config,
+                                        PPP_INPUTPARA *ppp_inputpara,
+                                        PPP_INFO *ppp_info);
+
+DM_EXTERN_API const char *DownmixCodecVersionInfo (void);
+
+#endif
+
--- /dev/null
+++ gst-fsl-plugins-3.0.7/inc/core_lib/nb_amr_enc_api.h
@@ -0,0 +1,162 @@
+
+/*
+* Copyright (c) 2004-2010, 2013, Freescale Semiconductor, Inc. 
+*/
+
+/*
+* This library is free software; you can redistribute it and/or
+* modify it under the terms of the GNU Lesser General Public
+* License as published by the Free Software Foundation; either
+* version 2.1 of the License, or (at your option) any later version.
+*
+* This library is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* Lesser General Public License for more details.
+*
+* You should have received a copy of the GNU Lesser General Public
+* License along with this library; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+/********************************************************************************
+*
+* File Name: nb_amr_enc_api.h
+*
+* Description: This is a header file corresponding to nb_amr_enc_api.c.
+*/
+
+/****************************** Change History***********************************
+*   DD/MMM/YYYY     Code Ver     Description      Author
+*   -----------     --------     -----------      ------
+*   20/May/2004     0.1          File created     Ashok
+*   02/Jun/2004     1.0          Review rework    Ashok
+*   20/Jul/2004     1.1          Implemented        Ashok
+*                                API based on the
+*                                doc
+*   01/Jul/2008     1.2          Added version API Tao Jun
+*
+*******************************************************************************/
+#ifndef NB_AMR_ENC_API_H
+#define NB_AMR_ENC_API_H
+/*****************************<INCLUDE_FILES BEGIN>****************************/
+#ifndef _OS_VRTX
+#include <stdio.h>
+#endif
+#include "nb_amr_common_api.h"
+/*******************************<INCLUDE_FILES END>****************************/
+
+/******************************<DEFINES BEGIN>*********************************/
+
+/* this define should be set to non-zero val to enable debug log
+ * Following are the value and corresponding enabling
+ * 0x0 -> log disbale
+ * 0x1 -> log level 0 enable
+ * 0x2 -> log level 1 will get enabled
+ * 0x3 -> 0 and 1 both will get enabled
+ * 0x4 -> log level 2 will be enabled
+ * 0xf -> all log level will be enabled
+ */
+
+#define NBAMRE_DBGLOG_LVL 0x0
+
+/* start val of debug log msg id, should be modified as per integration
+ * requirement
+ */
+#define NBAMRE_BEGIN_DBGLOG_MSGID  200
+/* end of debug log message */
+#define NBAMRE_END_DBGLOG_MSGID  399
+
+/******************************<DEFINES END>***********************************/
+
+/******************************<ENUMS BEGIN>***********************************/
+/***** Encoder return type, other return value to be added ****/
+/* Success is assigned to 0. As of now there can be 20 warnings,
+   starting from 11 to 30. Recoverable errors can be 20, starting
+   from 31 to 50. Fatal errors can be 20, starting from 51 to 70.
+   Later more error types can be added */
+typedef enum
+{
+     E_NBAMRE_OK =0,
+     E_NBAMRE_WARNING = NBAMR_WARNING_BASE,
+     E_NBAMRE_INVALID_MODE = NBAMR_RECOVERROR_BASE,
+     E_NBAMRE_INIT_ERROR,
+     E_NBAMRE_INVALID_ENCODER_ARGS,
+     E_NBAMRE_INPUT_READERROR,
+     E_NBAMRE_MEMALLOC_ERROR = NBAMR_FATALERROR_BASE,
+     E_NBAMRE_ERROR
+} eAMREReturnType;
+/******************************<ENUMS END>*************************************/
+
+/****************************<STRUCTURES/UNIONS BEGIN>*************************/
+typedef struct
+ {
+	NBAMR_S32	s32AMRESize;	    /* Size in bytes */
+	NBAMR_S32 	s32AMREMemType;	    /* Memory is static or scratch */
+	NBAMR_S32 	s32AMREMemTypeFs;	/* Memory type FAST or SLOW */
+	NBAMR_Void	*pvAPPEBasePtr;	    /* Pointer to the base memory,
+						               that will be allocated
+						               and  filled by the application*/
+	NBAMR_U8	u8AMREMemPriority;	/* Priority level */
+} sAMREMemAllocInfoSubType;
+
+/*Memory information structure array*/
+typedef struct
+{
+	/* Number of valid memory requests */
+	NBAMR_S32				    s32AMRENumMemReqs;
+	sAMREMemAllocInfoSubType 	asMemInfoSub[NBAMR_MAX_NUM_MEM_REQS];
+} sAMREMemAllocInfoType;
+
+/* encoder parameter structure */
+typedef struct
+{
+	sAMREMemAllocInfoType   sAMREMemInfo;
+	NBAMR_Void			    *pvAMREEncodeInfoPtr;
+    NBAMR_U8                *pu8APPEInitializedDataStart;
+	NBAMR_S16			    s16APPEDtxFlag;
+	NBAMR_S8			    **pps8APPEModeStr;
+	NBAMR_S8		        **pps8AMREUsedModeStr;
+	NBAMR_U32               *pu32AMREPackedSize; /* size of packed data in case of
+                                                   MMS, IF1 and IF2 */
+    NBAMR_U8                u8BitStreamFormat;
+    NBAMR_U8                u8NumFrameToEncode;    /* number of frame to be encoded */
+    NBAMR_U8                watermarkFlag;         /* watermark Flag for codec protection */
+} sAMREEncoderConfigType;
+/****************************<STRUCTURES/UNIONS END>***************************/
+
+/***************************<GLOBAL_VARIABLES BEGIN>***************************/
+                                    /* None */
+/***************************<GLOBAL_VARIABLES END>*****************************/
+
+/**************************<STATIC_VARIABLES BEGIN>****************************/
+                                    /* None */
+/**************************<STATIC_VARIABLES END>******************************/
+
+/**************************<FUNCTION_PROTOTYPES BEGIN>*************************/
+#ifdef __SYMBIAN32__
+#define EXTERN
+#define EXPORT_C __declspec(dllexport)
+#else
+#define EXTERN
+#define EXPORT_C
+#endif
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+ EXTERN eAMREReturnType eAMREEncodeInit (sAMREEncoderConfigType *psEncConfig);
+
+ EXTERN eAMREReturnType eAMREEncodeFrame (
+                sAMREEncoderConfigType *psEncConfig,
+				NBAMR_S16 *ps16InBuf,NBAMR_S16 *ps16OutBuf);
+
+ EXTERN eAMREReturnType eAMREQueryMem (
+                sAMREEncoderConfigType *psEncConfig);
+  const char * eAMREVersionInfo(void);
+#ifdef __cplusplus
+}
+#endif
+/**************************<FUNCTION_PROTOTYPES END>***************************/
+#endif /* end of NB_AMR_ENC_API_H header file */
+/**************************<END OF THE FILE>***********************************/
--- /dev/null
+++ gst-fsl-plugins-3.0.7/inc/core_lib/mpeg4_asp_api.h
@@ -0,0 +1,217 @@
+/*
+ * Copyright (c) 2005-2010, 2013 Freescale Semiconductor, Inc.
+ */
+
+/*
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+/****************************************************************************
+** mpeg4_asp_api.h 
+** 
+** 
+** Description: Main file of Video Decoder Tester.
+**
+** Author:
+**     Qiang Ding   <b02550@freescale.com>
+**     
+** Revision History: 
+** ----------------- 
+** 0.1  12/30/2008  Qiang Ding   Created this draft version
+*****************************************************************************/ 
+#ifndef __MPEG4_ASP_DEC_API__
+#define __MPEG4_ASP_DEC_API__
+
+#ifdef __cplusplus
+#define EXTERN extern "C"
+#else
+#define EXTERN
+#endif
+
+/* The handle of decoder is the only identifier of a certain decoder instance. */
+typedef void* MPEG4DHandle;
+
+/* This enum holds the memory alignment type */
+typedef enum
+{
+    E_MPEG4D_ALIGN_1BYTE = 0,	/*!< buffer can start at any place    */
+    E_MPEG4D_ALIGN_2BYTE,	       /*!< start address's last 1 bit has to be 0  */
+    E_MPEG4D_ALIGN_4BYTE,	       /*!< start address's last 2 bits has to be 0 */
+    E_MPEG4D_ALIGN_8BYTE,	       /*!< start address's last 3 bits has to be 0 */
+    E_MPEG4D_ALIGN_16BYTE,	       /*!< start address's last 4 bits has to be 0 */
+    E_MPEG4D_ALIGN_32BYTE,	       /*!< start address's last 5 bits has to be 0 */
+} eMpeg4DecMemAlignType;
+
+/* This describes the memory chunk requirement details such as size, type, etc.  */
+typedef struct
+{
+    signed long  			s32Size;	/*!< size of the memory block           */
+    eMpeg4DecMemAlignType	eAlign;	/*!< alignment of the memory block      */
+    void 			*            pvBuffer;/*!< pointer to allocated memory buffer */
+} sMpeg4DecMemBlock;
+
+/* Required memory information */
+typedef struct
+{
+    sMpeg4DecMemBlock sFastMemBlk;  /*!Fast memory Block */
+    sMpeg4DecMemBlock sSlowMemBlk; /*!Slow memory Block */
+} sMpeg4DecMemAllocInfo;
+
+/* high level stream information */
+typedef struct
+{
+/*VOS level*/
+    signed long    s32Profile;      /*stream profile, 0 for SP, 1 for ASP*/
+    signed long    s32Level;        /*stream level*/
+/*VOL level*/	
+    unsigned short u16PaddedFrameWidth;  /*!< Padded FrameWidth*/
+    unsigned short u16PaddedFrameHeight; /*!< Padded FrameHeight*/
+    unsigned short u16ActFrameWidth;         /*!< Actual FrameWidth */
+    unsigned short u16ActFrameHeight;        /*!< Actual FrameHeight*/
+    unsigned short u16LeftOffset;            /*cropping origin x*/
+    unsigned short u16TopOffset;             /*cropping origin y*/
+
+} sMpeg4DecStreamInfo;
+
+/* This structure holds initial information that the decoder needs to work */
+typedef struct
+{
+    sMpeg4DecMemAllocInfo	sMemInfo;
+    sMpeg4DecStreamInfo	sStreamInfo;
+    signed long           s32MinFrameBufferCount;
+} sMpeg4DecInitInfo;
+
+/* This Data structure encapsulates the decoded YCbCr buffer. */
+typedef struct
+{
+    unsigned char   *pu8YBuf;     /*!< Y Buf       must be 4 bytes aligned*/
+    unsigned char   *pu8UBuf;     /*!< U Buf       must be 4 bytes aligned*/
+    unsigned char   *pu8VBuf;     /*!< V Buf       must be 4 bytes aligned*/
+
+    signed long     s32YBufLength; /*size must be padded_width x padded_height, maybe need not this item*/
+    signed long     s32UBufLength; /*size must be padded_width x padded_height/4, maybe need not this item*/
+    signed long     s32VBufLength; /*size must be padded_width x padded_height/4, maybe need not this item*/
+    void *             pUsrTag  ;      /*a Tag that may be used by App. App can use this tag to easily manage the buffers.
+                                     It's App implementation dependent, decoder will not use or change this tag, 
+                                     App can ignore this tag also.*/
+} sMpeg4DecYCbCrBuffer;
+
+/* The callback functions used for getting frame buffers is defined below; it will get one frame buffer for decoder */
+typedef void * (*cbGetOneFrameBuffer)( void* pvAppContext);
+
+/* It is possible that the gotten frame buffer for decoding the current frame still stored the reference data 
+   so the decoder has to reject the buffer. After the rejection by calling this callback function, 
+   the decoder will invoke cbGetOneFrameBuffer to ask for frame buffer again */
+typedef void (*cbRejectOneFrameBuffer)( void * mem_ptr, void* pvAppContext);
+
+typedef void (*cbReleaseOneFrameBuffer)( void * mem_ptr, void* pvAppContext);
+
+/* the above callback functions are grouped into a structure named FrameManager */
+typedef struct _sMpeg4DecFrameManager
+{
+    cbGetOneFrameBuffer 	 GetterBuffer;
+    cbRejectOneFrameBuffer 	 RejectorBuffer;
+    cbReleaseOneFrameBuffer ReleaseBuffer;
+    void*			              pvAppContext ;
+}sMpeg4DecFrameManager; 
+
+/* This structure can be used to facilitate the decoder to refine configuration according to 
+** the application/platform's setting.  The maximum size of fast or slow memory (in bytes) 
+** that the the application can allocate for the decoder, -1 for unrestricted  */
+typedef struct
+{
+	  signed long  s32MaxFastMem;
+	  signed long  s32MaxSlowMem;
+} sMpeg4DecAppCap;
+
+/* This enum holds the return types of the APIs */
+typedef enum
+{ 
+	/* Successfull return values */
+	E_MPEG4D_SUCCESS = 0,                  /* Success */
+	E_MPEG4D_NO_OUTPUT,	                   /* decoded a frame but didn't finish, or it's NULL frame */
+	E_MPEG4D_FRAME_SKIPPED,	               /* skipped this frame*/
+	/* Successful return with a warning, decoding can continue */
+		
+	/* Recoverable error return, correct the situation and continue */
+	E_MPEG4D_NOT_ENOUGH_BITS=31,           /* Not enough bits are provided to get width/height  */
+	E_MPEG4D_OUT_OF_MEMORY,                /* Out of Memory                	*/
+	E_MPEG4D_WRONG_ALIGNMENT,              /* Incorrect Memory Alignment        	*/
+	E_MPEG4D_SIZE_CHANGED,                 /* Image size changed           */
+	E_MPEG4D_INVALID_ARGUMENTS,            /* API arguments are invalid		*/
+	E_MPEG4D_NO_HEADER_INFO,               /* no header in the stream when start to decode*/
+		
+	/* irrecoverable error type */
+	E_MPEG4D_ERROR_STREAM=51,              /* Errored Bitstream		*/
+	E_MPEG4D_FAILURE,                      /* Failure   		*/
+	E_MPEG4D_UNSUPPORTED,                  /* Unsupported Format          */
+	E_MPEG4D_NO_FRAME_BUFFER	             /* decoder can't get frame buffer */
+
+} eMpeg4DecRetType;
+
+/* For parameters setting and getting */
+//typedef enum _eMPEG4DParameter 
+//{
+//	E_MPEG4_PARA_SKIP_B_FRAME=0,
+//	E_MPEG4_PARA_SKIP_BNP_FRAME
+//} eMPEG4DParameter;
+
+/******************************************************************************************************/
+
+/* The application uses this function to query the initialization info such as memory requirement 
+   and minimal decoder buffer number of the decoder for a specific stream. 
+   This function would return the initialization info for the decoder with being fed with the stream header. 
+ */
+EXTERN eMpeg4DecRetType eMPEG4DQueryInitInfo(sMpeg4DecInitInfo *psInitInfo, unsigned char  *pu8BitBuffer, signed long s32NumBytes, sMpeg4DecAppCap *pAppCap);
+EXTERN eMpeg4DecRetType eMPEG4DQueryInitInfo_oldDX(sMpeg4DecInitInfo *psInitInfo, unsigned long uiWidth, unsigned long uiHeight, sMpeg4DecAppCap *pAppCap);
+
+/* Create the decoder instance */
+EXTERN eMpeg4DecRetType eMPEG4DCreate (sMpeg4DecInitInfo* psInitInfo, sMpeg4DecFrameManager* pFrameManager,	MPEG4DHandle* phMp4DecHandle); 
+
+/* This is the main decoder function which should be called for decoding each frame.  */
+EXTERN eMpeg4DecRetType eMPEG4DDecodeFrame (MPEG4DHandle hMp4DecHandle, void *pvBSBuf, long *s32NumBytes);
+EXTERN eMpeg4DecRetType eMPEG4DDecodeFrame_oldDX (MPEG4DHandle hMp4DecHandle, void *pvBSBuf, long *s32NumBytes, int width, int height);
+
+/* Flush one frame to avoid the frame was reserved by decoder. */
+EXTERN eMpeg4DecRetType eMPEG4DFlushFrame (MPEG4DHandle hMp4DecHandle);
+
+/* Get the frame to be displayed, the cropping work will be carried out in the application's scope. */
+EXTERN eMpeg4DecRetType eMPEG4DGetOutputFrame (MPEG4DHandle hMp4DecHandle, sMpeg4DecYCbCrBuffer** ppsOutBuffer);
+
+/* This function sets some indications to decoder to configure the additional features of the decoder */
+EXTERN eMpeg4DecRetType eMPEG4DSetParameter (MPEG4DHandle hMp4DecHandle, int eParaName/*, void * u32ParaValue*/ );
+
+/* This function is used for querying the current configuration of the decoder. */
+EXTERN eMpeg4DecRetType eMPEG4DGetParameter (MPEG4DHandle hMp4DecHandle, /*eMPEG4DParameter eParaName, */void * pu32ParaValue );
+
+/* Get the codec version information */
+EXTERN const char * eMPEG4DCodecVersionInfo(void);
+
+/* 
+*******************************************************************************************
+The acceptable name and value pairs 
+-----------------------------------------------------------------------------------------
+Parameter Name	                                   Parameter Value
+-----------------------------------------------------------------------------------------
+E_MPEG4_PARA_SKIP_B_FRAME	                       0: do not skip B frame(default value)
+                                                   1: skip B frame
+                                                   
+E_MPEG4_PARA_SKIP_BNP_FRAME	                       0: do not skip B or P frame(default value)
+                                                   1: skip B and P frame
+                                                   
+*******************************************************************************************
+*/
+
+#endif
--- /dev/null
+++ gst-fsl-plugins-3.0.7/inc/core_lib/nb_amr_common_api.h
@@ -0,0 +1,133 @@
+
+/*
+* Copyright (c) 2004-2010, 2013, Freescale Semiconductor, Inc. 
+*/
+
+/*
+* This library is free software; you can redistribute it and/or
+* modify it under the terms of the GNU Lesser General Public
+* License as published by the Free Software Foundation; either
+* version 2.1 of the License, or (at your option) any later version.
+*
+* This library is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* Lesser General Public License for more details.
+*
+* You should have received a copy of the GNU Lesser General Public
+* License along with this library; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+/********************************************************************************
+* File Name: nb_amr_common_api.h
+*
+* Description: This is common header file included by encoder and decoder both
+*************************************************************************/
+
+/****************************** Change History***********************************
+*   DD/MMM/YYYY     Code Ver     Description      Author
+*   -----------     --------     -----------      ------
+*   20/May/2004     0.1          File created     Ashok
+*   02/Jun/2004     1.0          Review rework    Ashok
+*   20/Jul/2004     1.1          Implemented        Ashok
+*                                API based on the
+*                                doc
+*******************************************************************************/
+#ifndef NB_AMR_COMMON_API_H
+#define NB_AMR_COMMON_API_H
+/*****************************<INCLUDE_FILES BEGIN>****************************/
+#ifndef _OS_VRTX
+#include <stdio.h>
+#endif
+/*******************************<INCLUDE_FILES END>****************************/
+/******************************<DEFINES BEGIN>*********************************/
+#define     NBAMR_TRUE     1
+#define     NBAMR_FALSE    0
+#define     NBAMR_SUCCESS  0
+#define     NBAMR_FAILURE  1
+#define     NBAMR_MEM_STATIC      0
+#define     NBAMR_MEM_SCRATCH     1
+#define     NBAMR_FAST_MEMORY     0
+#define     NBAMR_SLOW_MEMORY     1
+#define     NBAMR_MAX_NUM_MEM_REQS	20
+#define     NBAMR_PRIORITY_LOWEST  255
+#define     NBAMR_PRIORITY_NORMAL  128
+#define     NBAMR_PRIORITY_HIGHEST 0
+
+/* for future use */
+#define     NBAMR_BEGIN_DATA TBD /* to be decided by application */
+#define     NBAMR_MEM_TYPE        FAST_MEMORY
+
+#define     MAX_SERIAL_SIZE 244
+#define     SERIAL_FRAMESIZE    (1+MAX_SERIAL_SIZE+5)
+#define     L_FRAME         160
+
+#define     NBAMR_WARNING_BASE	    11
+#define     NBAMR_RECOVERROR_BASE	31
+#define     NBAMR_FATALERROR_BASE	51
+
+#define    NBAMR_MAX_NUM_MODES      16
+
+/********************** Data types ******************************/
+
+/********define 8 bit signed/unsigned types & constants *********/
+typedef void	NBAMR_Void;
+typedef signed char NBAMR_S8;
+typedef unsigned char NBAMR_U8;
+
+/********define 16 bit signed/unsigned types & constants *********/
+
+typedef short NBAMR_S16;
+typedef unsigned short NBAMR_U16;
+
+/********define 32 bit signed/unsigned types & constants *********/
+typedef long NBAMR_S32;
+typedef unsigned long NBAMR_U32;
+
+#define NBAMR_MAGIC_NUMBER           "#!AMR\n"
+/* for MMS and IF2 file format MAX_PACKED_SIZE = MAX_SERIAL_SIZE/8 +2
+ * whereas for IF1 it should be MAX_SERIAL_SIZE/8+4.
+ * but to make allocation same for all the three file format
+ * it is defined MAX_PACKED_SIZE/8+4 = 34 bytes
+ */
+#define NBAMR_MAX_PACKED_SIZE     (MAX_SERIAL_SIZE/8 + 4)
+
+/* define used to check Non DTX configuration */
+#define NBAMR_NONDTX        0
+/* define used to check VAD1 configuration */
+#define NBAMR_VAD1          1
+/* define used to check VAD2 configuration */
+#define NBAMR_VAD2          2
+
+/* NB-AMR file format */
+#define NBAMR_ETSI      0
+/* MMS format */
+#define NBAMR_MMSIO     1
+/* IF1 format */
+#define NBAMR_IF1IO     2
+/* IF2 format */
+#define NBAMR_IF2IO     3
+/******************************<DEFINES END>***********************************/
+
+/******************************<ENUMS BEGIN>***********************************/
+                                /* NONE */
+/******************************<ENUMS END>*************************************/
+
+/****************************<STRUCTURES/UNIONS BEGIN>*************************/
+                                /* NONE */
+/****************************<STRUCTURES/UNIONS END>***************************/
+
+/***************************<GLOBAL_VARIABLES BEGIN>***************************/
+                                    /* None */
+/***************************<GLOBAL_VARIABLES END>*****************************/
+
+/**************************<STATIC_VARIABLES BEGIN>****************************/
+                                    /* None */
+/**************************<STATIC_VARIABLES END>******************************/
+
+/**************************<FUNCTION_PROTOTYPES BEGIN>*************************/
+                                   /* None */
+/**************************<FUNCTION_PROTOTYPES END>***************************/
+#endif /* end of NBAMR_COMMON_API_H header file */
+/**************************<END OF THE FILE>***********************************/
--- /dev/null
+++ gst-fsl-plugins-3.0.7/inc/core_lib/wmv789_dec_api.h
@@ -0,0 +1,430 @@
+/*
+ * Copyright (c) 2005-2010, 2013 Freescale Semiconductor, Inc.
+ */
+
+/*
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+/***********************************************************************
+*
+* File Name: wmv9_dec_api.h
+*
+* Description: This header file describes all the enumerations, data types,
+*              structures, macros and functions to be exposed to the
+*              application developers.
+*
+****************************** Change History**************************
+*
+*    DD/MMM/YYYY     Code Ver     Description            Author
+*    -----------     --------     -----------            ------
+* 01 Feb 2005        0.1       Intial version            Debashis Sarkar
+* 04 Feb 2005        0.2       First version that runs   Debashis
+* 16 Feb 2005        0.3       Review comments           Debashis
+* 23 Aug 2006        0.4       Updated for UYVY          Prachi/Pavan
+*                              support:TLSbo75126
+* 24 Nov 2006        0.5       Increased the maximum     Abhishek M
+*                              number of mem requests
+*                              from 256 to 512.
+*                              Added an memory type
+*                              to indicate
+*                              whether buffer holds the
+*                              output (TLSbo79957)
+* 2 Jan 2007         0.6       Changes for getting       Abhishek M
+*                              padded/non-padded o/p
+* 19 June 2008      0.7   add demo protection and api version    Eagle Zhou: ENGR00080797
+***********************************************************************/
+
+#ifndef WMV9_DEC_API_H
+#define WMV9_DEC_API_H
+
+
+/*********** Basic data types ***********/
+
+typedef void               WMV9D_Void;
+
+typedef int                WMV9D_S32;
+typedef unsigned int       WMV9D_U32;
+
+typedef short int          WMV9D_S16;
+typedef short unsigned int WMV9D_U16;
+
+typedef char               WMV9D_S8;
+typedef unsigned char      WMV9D_U8;
+
+
+/******** Call back function pointer type, used in data retrieving *********/
+
+typedef WMV9D_S32 (*FpWmv9DecReadCbkType) (WMV9D_S32 s32BufLen,
+                                           WMV9D_U8* pu8Buf,
+                                           WMV9D_S32* bEndOfFrame,
+                                           WMV9D_Void* pvAppContext);
+
+
+/**************        Macro definitions        *****************/
+
+/* memory types not exactly a bitfield, but could have been */
+
+/* Slow memory is reasonable, and expected */
+#define WMV9D_SLOW_MEMORY       0x0001
+
+/* Fast memory is adviced and desirable. It will have impact on performance */
+#define WMV9D_FAST_MEMORY       0x0002
+
+/* Memory content is used over API calls, and can not be reused in between */
+#define WMV9D_STATIC_MEMORY     0x0004
+
+/* Memory content is not used over API calls, and can be reused in between */
+#define WMV9D_SCRATCH_MEMORY    0x0008
+
+/* Memory required can change, depending of the frame size, or sequence */
+#define WMV9D_SIZE_DEPENDENT    0x0010
+
+/* Memory size has changed after last allocation, or it is being initialized */
+#define WMV9D_SIZE_CHANGED      0x0020
+
+/* Memory needs to be copied to new location, if reallocation happens.
+ * The size to be copied is minimum of old size and current size */
+#define WMV9D_COPY_AT_RESIZE    0x0040
+
+//#ifdef OUTPUT_BUFFER_CHANGES
+/*memory req for output buffers*/
+#define WMV9D_OUTPUT_MEMORY    0x0080
+//#endif
+
+
+
+/****** macros to extract memory types ******/
+
+/* Returns true if the memory required is fast */
+#define WMV9D_IS_FAST_MEMORY(memType)       ((memType) & WMV9D_FAST_MEMORY)
+
+/* Returns true if the memory reuired can be slow */
+#define WMV9D_IS_SLOW_MEMORY(memType)       ((memType) & WMV9D_SLOW_MEMORY)
+
+
+/* Returns true if the memory usage is static type */
+#define WMV9D_IS_STATIC_MEMORY(memType)     ((memType) & WMV9D_STATIC_MEMORY)
+
+/* Returns true if the memory content is not used over API calls */
+#define WMV9D_IS_SCRATCH_MEMORY(memType)    ((memType) & WMV9D_SCRATCH_MEMORY)
+
+
+/* Returns true, if the buffer size depends on frame size and/or sequence */
+#define WMV9D_IS_SIZE_DEPENDENT_MEMORY(memType) \
+                                            ((memType) & WMV9D_SIZE_DEPENDENT)
+
+/* Returns true if the buffer size has changed after last allocation */
+#define WMV9D_IS_SIZE_CHANGED(memType)      ((memType) & WMV9D_SIZE_CHANGED)
+
+/* Returns true, if the buffer needs to be copied while reallocating */
+#define WMV9D_NEEDS_COPY_AT_RESIZE(memType) ((memType) & WMV9D_COPY_AT_RESIZE)
+
+/* Returns true, if the buffer holds output data */
+//#ifdef OUTPUT_BUFFER_CHANGES
+#define WMV9D_IS_OUTPUT_MEMORY(memType)     ((memType) & WMV9D_OUTPUT_MEMORY)
+//#endif
+/*
+ * Define to control the loging level. Can be set from build command or here.
+ * The debug levels are currently defined at 4 levels, sequence layer [bit0],
+ * frame layer [bit1], macroblock layer [bit3] and block layer [bit4]. There
+ * is no debug level for each pixel, as it is too much of data to handle. To
+ * enable debug at any level, set the corresponding bit to 1. To enable
+ * function entry and exit, use bit7. Please note that function entry and
+ * exit will be loged only for the levels, where the debug is on.
+ */
+
+//#ifndef WMV9_DEBUG_LEVEL
+#define WMV9_DEBUG_LEVEL  0x00    /* no debugging is set */
+//#endif
+
+
+/*
+ * Maximum number of memory requests that can be made by the decoder. Do not
+ * modify this value.
+ */
+//#ifndef WMV9_SIMPLE_ONLY
+//#define WMV9D_MAX_NUM_MEM_REQS              512
+//#else
+#define WMV9D_MAX_NUM_MEM_REQS              256
+//#endif
+
+/*
+ * Bit buffer size used by the decoder. The memory required for this is
+ * allocated through memquery API as fast memory. Do not make it huge, as
+ * it is never required to hold more than one frame worth data at any given
+ * time. It may contain part of one frames data, if frame data size is larger.
+ */
+
+#define WMV9D_BIT_BUFFER_LENGTH    256
+
+
+/*********** enumeration types ***********/
+
+/*
+ * Return types from all of the decoder API's, except the format converter
+ */
+
+typedef enum
+{
+    /* Successfull return values */
+    E_WMV9D_SUCCESS = 0,          /* Successful completion                  */
+
+    /* Successful return with a warning, no action needs to be taken */
+    E_WMV9D_ERROR_CONCEALED = 11, /* Error in the bit stream, but concealed */
+    E_WMV9D_ENDOF_BITSTREAM,      /* End of Bit Stream                      */
+
+    /* Successful return with a warning, correct the situation and continue */
+    E_WMV9D_NOT_ENOUGH_BITS=31,   /* Not enough bits are provided           */
+    E_WMV9D_BAD_MEMORY,           /* Out of memory                          */
+    E_WMV9D_WRONG_ALIGNMENT,      /* Incorrect memory alignment             */
+    E_WMV9D_SIZE_CHANGED,         /* Image size changed                     */
+    E_WMV9D_NO_OUTPUT,            /* No output frame is available           */
+    E_WMV9D_BROKEN_FRAME,         /* Should have more data in this frame    */
+    E_WMV9D_DEMO_PROTECT,         /* the output is corrupted by demo protection    */
+
+    /* irrecoverable error type, may need re-initialization to continue */
+    E_WMV9D_CORRUPTED_BITS=51,    /* Error bit stream                       */
+    E_WMV9D_FAILED,               /* Failure                                */
+    E_WMV9D_UNSUPPORTED,          /* Unsupported format                     */
+    E_WMV9D_NO_KEYFRAME_DECODED,  /* first frame is not an I frame          */
+    E_WMV9D_SIZE_NOT_FOUND,       /* Frame size not found in bit stream     */
+    E_WMV9D_NOT_INITIALIZED,      /* Decoder is not initialized             */
+    E_WMV9D_INVALID_ARGUMENTS     /* Argument to the API is invalid         */
+} eWmv9DecRetType;
+
+
+/*
+ * Memory alignment types enumeration.
+ */
+
+typedef enum
+{
+    E_WMV9D_ALIGN_NONE = 0,       /* buffer can start at any place          */
+    E_WMV9D_ALIGN_HALF_WORD,      /* address's last bit has to be 0         */
+    E_WMV9D_ALIGN_WORD,           /* address's last 2 bits has to be 0      */
+    E_WMV9D_ALIGN_DWORD,          /* address's last 3 bits has to be 0      */
+    E_WMV9D_ALIGN_QWORD,          /* address's last 4 bits has to be 0      */
+    E_WMV9D_ALIGN_OCTAWORD        /* address's last 5 bits has to be 0      */
+} eWmv9DecMemAlignType;
+
+
+/*
+ * Type of the VOP decoded last.
+ */
+
+typedef enum
+{
+    E_WMV9D_INTRA_VOP,           /* Intra VOP or I-VOP	                    */
+    E_WMV9D_INTER_VOP,           /* Inter VOP or P-VOP	                    */
+    E_WMV9D_BIDIR_VOP,           /* Bidirectional VOP or B-VOP              */
+    E_WMV9D_UNKNOWN_VOP,         /* Unknown, should not happen              */
+} eWmv9DecVOPType;
+
+
+/*
+ * Defines the encoding bitstream. It does not cover all of the possible asf
+ * string. Use the converter function to convert the asf string to this type,
+ * in case multiple types are supported by same application. Otherwise (only
+ * one format is guranteed at the input) application can use the corresponding
+ * value directly, without trying to use asf format string.
+ */
+
+typedef enum
+{
+    E_WMV9D_COMP_FMT_WMV9,       /* WMV9 encoded bitstream                  */
+    E_WMV9D_COMP_FMT_WMV8,       /* WMV8 encoded bitstream                  */
+    E_WMV9D_COMP_FMT_WMV7,       /* WMV7 encoded bitstream                  */
+    E_WMV9D_COMP_FMT_UNSUPPORTED /* Unsupported encoded bitstream           */
+} eWmv9DecCompFmtType;
+
+
+
+/************ Decoder data structures ***********/
+
+/* Data structure to define each memory block request */
+
+typedef struct
+{
+    WMV9D_S32            s32Size;     /* Current size requirement            */
+    WMV9D_S32            s32MemType;  /* Memory type description             */
+    WMV9D_S32            s32Priority; /* determines impact on the performance */
+    eWmv9DecMemAlignType eMemAlign;   /* Memory alignment of the buffer      */
+    WMV9D_S32            s32OldSize;  /* Old size, in case being reallocated */
+    WMV9D_S32            s32MaxSize;  /* Maximum size that can be asked for  */
+    WMV9D_Void*          pvUnalignedBuffer;  /* unaligned buffer pointer     */
+    WMV9D_Void*          pvBuffer;    /* buffer start address with alignment */
+} sWmv9DecMemBlockType;
+
+
+/*
+ * Data structure to define the complete memmory requests
+ */
+
+typedef struct
+{
+    WMV9D_S32             s32NumReqs;  /* Number of valid requests           */
+    sWmv9DecMemBlockType  asMemBlks[WMV9D_MAX_NUM_MEM_REQS]; /* requests     */
+} sWmv9DecMemAllocInfoType;
+
+
+/*Added to support UYVY and IYUV and IYUV padded data*/
+
+typedef enum tagVideoFormat_WMC
+{
+    IYUV_WMV=0,
+
+    //#ifdef OUTPUT_BUFFER_CHANGES
+    IYUV_WMV_PADDED,
+    //#endif
+
+    //#ifndef WMV9_SIMPLE_ONLY
+    //UYVY_WMV
+    //#endif
+
+} tVideoFormat_WMC;
+
+
+
+/*
+ * Structure to hold the decoded frame information.
+ * Please note that currently the row size for Cb and Cr contains same value
+ */
+
+typedef struct
+{
+    WMV9D_U8* pu8YBuf;      /* Y component data buffer start address  */
+    WMV9D_U8* pu8CbBuf;     /* Cb component data buffer start address */
+    WMV9D_U8* pu8CrBuf;     /* Cr component data buffer start address */
+
+    WMV9D_S32       s32YRowSize;  /* Row size of Y data buffer  (padded width Luma)            */
+    WMV9D_S32       s32CbRowSize; /* Row size of Cb data buffer (padded width Chroma)          */
+    WMV9D_S32       s32CrRowSize; /* Row size of Cr data buffer (padded width Chroma)          */
+    //#ifdef OUTPUT_BUFFER_CHANGES
+    tVideoFormat_WMC tOutputFormat;
+    //#endif
+} sWmv9DecYCbCrBufferType;
+
+
+/*
+ * Structure to hold the parameters that are passed from application to
+ * decoder and vice versa. Frame rate and bitrate, though set by application
+ * initialy, can be corrected by decoder while initilizing.
+ */
+
+typedef struct
+{
+    sWmv9DecYCbCrBufferType sOutputBuffer;      /* decoded frame information */
+    eWmv9DecCompFmtType     eCompressionFormat; /* encoding format info      */
+    WMV9D_S32               s32FrameRate;       /* Frame rate in fps         */
+    WMV9D_S32               s32BitRate;         /* Bit rate in bps           */
+    WMV9D_U16               u16FrameWidth;      /* Frame width in pixels     */
+    WMV9D_U16               u16FrameHeight;     /* Frame hight in pixels     */
+    WMV9D_U32               u32PrevFrameNum;    /* Please see the API doc    */
+    WMV9D_U32               u32CurrFrameNum;    /* Last decoded frame number */
+    eWmv9DecVOPType         eVopType;           /* Last decoded frame's type */
+} sWmv9DecParamsType;
+
+
+/*
+ * Main WMV9 decoder object. This is used in all decoder API.
+ */
+
+typedef struct
+{
+    sWmv9DecMemAllocInfoType sMemInfo;     /* memory requirements            */
+    sWmv9DecParamsType       sDecParam;    /* sequence/frame paramters       */
+    WMV9D_Void*              pvWmv9Obj;    /* internal decoder object        */
+    WMV9D_Void*              pvBitBuffer;  /* buffer for bitstream           */
+    WMV9D_Void*              pvAppContext; /* application context for cbk    */
+    FpWmv9DecReadCbkType     pfCbkBuffRead;/* Callback function pointer      */
+} sWmv9DecObjectType;
+
+
+
+
+/************  function definitions *****************/
+
+/* Small utility functions, helpful to the application */
+
+/*
+ * Returns the compression format type used in API, given the ASF file
+ * compression format string. Right now, only WMV[123] strings are supported.
+ * For the rest types, it returns unsupported format type.
+ */
+
+#ifdef __cplusplus
+#define EXTERN extern "C"
+#else
+#define EXTERN
+#endif
+
+EXTERN eWmv9DecCompFmtType eWMV9DCompFormat (const WMV9D_U8* format);
+
+
+/***********  main API functions **********/
+
+/*
+ * Query for the memory requirement, given width and height of frame
+ * The decoder sets the Meminfo structure with the required memory buffer
+ * requests.
+ * TODO : The object already has width and height, do we need to pass
+ *        it separately ?
+ */
+
+EXTERN eWmv9DecRetType eWMV9DQuerymem (sWmv9DecObjectType* psWmv9Obj,
+                                WMV9D_S32 s32Height, WMV9D_S32 s32Width);
+
+
+
+/*
+ * Initialise the decoder object and parses the sequence header, if required.
+ * The memory requested should be met and the buffer pointers are provided.
+ * Decoder, after actual initialization, parses the sequence header and sets
+ * few decoder parameters (like frame rate, bitrate). It can potentially call
+ * the callback function, so set the function callback before calling API.
+ */
+
+EXTERN eWmv9DecRetType eWMV9DInit (sWmv9DecObjectType* psWmv9DecObj);
+
+
+
+/*
+ * Decode one frame from the bitstream,
+ * This function gets the data using the callback function, so make sure that
+ * it is properly set. The decoded data will be available as read only in the
+ * output frame buffer structure. If no frames has been skipped, the
+ * u32CurFrameNumber will provide the frame number for this frame.
+ */
+
+EXTERN eWmv9DecRetType eWMV9DDecode (sWmv9DecObjectType* psWmv9Obj,
+                              WMV9D_U32 u32FrameDataSize);
+
+
+
+/*
+ * Free the decoder structure (mainly reset the decoder internals)
+ */
+
+EXTERN eWmv9DecRetType eWMV9DFree (sWmv9DecObjectType *psWmv9Obj);
+
+//#ifdef OUTPUT_BUFFER_CHANGES
+/*! API to get the output frame*/
+EXTERN eWmv9DecRetType  eWMV9DecGetOutputFrame (sWmv9DecObjectType *psWmv9Obj);
+//#endif
+
+EXTERN const char * WMV9DecCodecVersionInfo();
+
+#endif /* WMV9_DEC_API_H  */
--- /dev/null
+++ gst-fsl-plugins-3.0.7/inc/core_lib/avcd_dec_api.h
@@ -0,0 +1,404 @@
+/*
+ * Copyright (c) 2005-2010, 2013 Freescale Semiconductor, Inc.
+ */
+
+/*
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+/*!
+ ***********************************************************************
+ *
+ *  \brief
+ *      Contains all the H.264 interface function definitions
+ *
+ *
+ *  \author
+ *      - Faisal Ishtiaq            <faisal@motorola.com> <BR>
+ *      - Raghavan Subramaniyan     <rags@labs.mot.com> <BR>
+ *      - Shan Yu                   <shanyu@labs.mot.com> <BR>
+ *      - Rohit Bodas               <bodas@labs.mot.com> <BR>
+ *      - Bhavan Gandhi             <gandhi@labs.mot.com> <BR>
+ *       Multimedia Communications Research Labs, Motorola Labs
+ *
+ *  \version
+ *      $Revision: 1.8 $ - $Date: 2004/03/24 20:54:11 $
+ *
+ *  \Revision History
+ *      MCRL             Created                          08 Aug, 2003
+ *      Chandra          Changed variable names              Oct, 2004
+ *                       and added Query Memory
+ *      Chandra          Added Requery                    5, Nov, 2004
+ *      Chandra          Added more return parameters    26, Nov, 2004
+ *      Raja             Added application data pointer
+ *                       to the callback functions       21, Nov, 2005
+ *
+ *
+ ***********************************************************************
+ */
+  /*!
+ ***********************************************************************
+ * Author                  Comments                          Date      *
+ * Abhishek Mehrotra    CR no - dsphl 27994(PAF Scheme)  9 March, 2006 *
+ *                      Code changes for PAF Scheme                    *
+ *                                                                     *
+ ***********************************************************************
+ */
+
+  /*
+****************************************************************************
+ * Freescale ShangHai Video Codec Team Change History
+
+  Version    Date                   Author		     CRs                       Comments
+  01           1/Apr/2008          Li Xianzhong    ENGR00068494      Add buffer release API
+  02           10/Apr/2008        Li Xianzhong     ENGR00072210     Add API to query physical address
+  03           13/Jun/2008        Li Xianzhong     ENGR00080171     Add API to query codec version info
+  04           25/Nov/2008        Chen Zhenyong    ENGR00100173     Syntax refinement;visibility declaration is added, sync with its implementation
+  05           05/10/2010 	      Lyon Wang        engr123203        add include render_type.h for name conflict when include different ghdr
+****************************************************************************
+*/
+
+#ifndef AVCD_DECODER_H
+#define AVCD_DECODER_H
+
+#include "render_type.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+#define AVCD_MAX_NUM_MEM_REQS          350
+#define AVCD_DEFAULT_LEVEL_SUPPORT     51
+
+/*! defines to specify type of memory. Only one of the two in each group
+ * (speed and usage) shall be on but not both.
+ */
+#define E_AVCD_SLOW_MEMORY       0x1   /*! slower memory is acceptable */
+#define E_AVCD_FAST_MEMORY       0x2   /*! faster memory is preferable */
+#define E_AVCD_STATIC_MEMORY     0x4   /*! content is used over API calls */
+#define E_AVCD_SCRATCH_MEMORY    0x8   /*! content is not used over
+                                             successessive Decode API calls */
+
+/*! retrieve the type of memory */
+
+#define AVCD_IS_FAST_MEMORY(memType)    (memType & E_AVCD_FAST_MEMORY)
+#define AVCD_IS_SLOW_MEMORY(memType)    (memType & E_AVCD_SLOW_MEMORY)
+#define AVCD_IS_STATIC_MEMORY(memType)  (memType & E_AVCD_STATIC_MEMORY)
+#define AVCD_IS_SCRATCH_MEMORY(memType) (memType & E_AVCD_SCRATCH_MEMORY)
+
+
+/*! \enum Specifies the return state of the APIs */
+typedef enum
+{
+    //!< Successful Completion
+    E_AVCD_NOERROR =  0,                  //!< Successful decoding of frame
+    E_AVCD_INIT,                          //!< Successful Initialization
+    E_AVCD_QUERY,                         //!< Successful Query
+    E_AVCD_SEQ_CHANGE,                    //!< Sequence Change Detected
+    E_AVCD_CHANGE_SERVICED,               //!< Changed serviced by requery
+    E_AVCD_FF,                            //!< In the fast forward state
+//DSPhl28316-begin
+//#if defined(DPB_FIX)
+	E_AVCD_FLUSH_STATE,					  //!< In the flush state
+//#endif
+//DSPhl28316-end
+    //!< Recoverable Errors, warnings and information
+    E_AVCD_NOT_SUPPORTED,
+    E_AVCD_BAD_PARAMETER,                 //!< Invalid parameter(s)
+    E_AVCD_BAD_DATA_PTR ,                 //!< DataPtr -> invalid memory
+    E_AVCD_NOMEM,                         //!< Not enough memory for decoding
+    E_AVCD_NO_FRAME_BUFFER_CHANGE,        //!< No change in buffer requirement
+    E_AVCD_FRAME_BUFFER_CHANGE,           //!< Change in memory requirement detected
+    E_AVCD_NO_OUTPUT,                     //!< Successful decode but output not generated
+    E_AVCD_NULL_POINTER,                  //!< Buffers not allocated as requested
+    E_AVCD_BAD_DATA,                      //!< Input data not decodable
+    //TLSbo72722
+    E_AVCD_OUTPUT_FORMAT_NOT_SUPPORTED,	  //!< Output format expected is not supported
+    //TLSbo72722-
+/*ENGR00035713    Add feature to tolerate bit-stream without Sequence and/or Picture NAL  start*/
+    /*these 2 error is recoverable, just try to feed in more NAL until these 2 kind of NAL appears
+    it means App can just treat these 2 types as  E_AVCD_NO_OUTPUT*/
+    E_NO_PICTURE_PAR_SET_NAL,        //!< did not receive PICTURE_PAR_SET_NAL yet
+    E_NO_SEQUENCE_PAR_SET_NAL,        //!< did not receive SEQUENCE_PAR_SET_NAL yet
+/*ENGR00035713    Add feature to tolerate bit-stream without Sequence and/or Picture NAL  end*/
+	/*ENGR80171 Add Demo protection type*/
+	E_AVCD_DEMO_PROTECT,                  //!<only for demo version, returned after decoded frame count is greater than 9000
+    //!< Irrecoverable Errors
+    E_AVCD_CODEC_TYPE_NOT_SUPPORTED,      //!< Unsupported codec type
+    E_AVCD_INVALID_PARAMETER_SET,         //!< Invalid Pic/Seq param set
+    E_AVCD_UNKNOWN_ERROR = 127,           //!< Some Unknown error
+}eAVCDRetType;
+
+/*! \enum Specifies the alignment requirement of the each of the memory to be allocated */
+typedef enum
+{
+   E_AVCD_BYTE_ALIGN = 0,
+   E_AVCD_HALFWORD_ALIGN,
+   E_AVCD_THIRDBYTE_ALIGN,
+   E_AVCD_WORD_ALIGN,
+}eAVCDAlign;
+
+//TLSbo72722
+/*! \enum Specifies the output format required */
+typedef enum
+{
+   E_AVCD_420_PLANAR = 0,
+   E_AVCD_420_PLANAR_PADDED,
+   E_AVCD_422_UYVY
+
+}eAVCDOutputFormat;
+//TLSbo72722-
+
+/*! Structure to hold each memory block requests from the decoder.
+ *  The size and alignment are must to meet crteria, whereas others
+ *  help to achive the performace projected. Usage is provided to help
+ *  the application to decide if the memory has to be saved, in case of
+ *  memory scarcity. Type of the memory has a direct impact on the
+ *  performance. Priority of the block shall act as a hint, in case not
+ *  all requested FAST memory is available. There is no gurantee that
+ *  the priority will be unique for all the memory blocks.
+ */
+typedef struct
+ {
+     int                 s32Size;                   //!< Size of the memory to be allocated
+     int                 s32Align;                  //!< memory usage -  static/scratch
+     int                 s32Type;                   //!< type of the memory slow/fast
+     int                 s32Priority;               //!< how important the block is
+     int                 s32SizeDependant;          /*!< Indication if the parameter
+                                                         depends on size of frame*/
+     int                 s32Allocate;               //!< Indicates memory is required to be
+                                                    //!< allocated to the element
+     int                 s32Copy;                   /*!< Indicates if whether data in previously
+                                                         allocated memory is to be
+                                                         copied before reallocaing memory*/
+     int                 s32MaxSize;                //!< Maximum possible size
+     void               *pvBuffer;                  //!< Pointer to the memory
+}sAVCDMemBlock;
+
+/*! Structure to hold all the memory requests from the decoder  */
+typedef struct
+{
+     int                 s32NumReqs;
+     sAVCDMemBlock       asMemBlks[AVCD_MAX_NUM_MEM_REQS];
+     int               s32MinFrameBufferNum;  /*!< minimum number of frame buffer*/
+}sAVCDMemAllocInfo;
+
+/*! Structure for defining the decoder output */
+typedef struct
+{
+    // 4:2:0 format is assumed
+    unsigned char       *pu8y, *pu8cb, *pu8cr;      //!< Ptr to Output Y.Cb.Cr buffer
+    long                 s32FrameNumber;            //!< Current Frame Number (@29.97 fps)
+    short                s16FrameWidth;             //!< Width of frame
+    short                s16FrameHeight;            //!< Height of frame
+    short                s16Xsize;                  /*!<
+                                                      X dimension of y buffer. Should
+                                                      be greater than or equal to
+                                                      frameWidth */
+    short                s16CxSize;                 /*!<
+                                                      X dimension of cb/cr buffer.
+                                                      Should be greater than or equal
+                                                      to frameWidth/2 */
+   //TLSbo72722
+   eAVCDOutputFormat 	eOutputFormat;				//!< Format of the output data, to be
+   //TLSbo72722-													//!< populated by the application before calling
+    int                 cropLeft_display;
+    int                 cropTop_display;
+
+  													//!< decoder init operation
+}
+sAVCDYCbCrStruct;
+
+/*! Structure for defining the latest decoder configuration (NAL unit that is decoded)*/
+typedef struct
+{
+    short                s16FrameWidth;              //!< Width of frame
+    short                s16FrameHeight;             //!< Height of frame
+    short                s16NumRefFrames;            //!< Number of reference frames used
+    short                s16Level;                   //!< Level of the decoded bitstream
+//DSPhl28316-begin
+//#if defined(DPB_FIX)
+	unsigned int		 u32MaxDPB;					//!< Max DPB supported for the corresponding level
+//#endif
+//DSPhl28316-end
+}
+sAVCDConfigInfo;
+
+/*! Structure for defining the Decoder Configuration */
+typedef struct
+{
+    // --- Parameters set by application ---
+    // NOTE: These need to be set before call to eAVCDInitVideoDecoder (by application)
+    long                 s32NumBytes;                //! Num of bytes in input buffer
+    unsigned short       s32NalType;                 //! Type of NAL unit being decoded
+
+    // --- Parameters set by video decoder ---
+    void                *pvInBuffer;                  //!< Ptr to Input Bitstream (1 NALU)
+    int                  s32FrameNumber;              //!< Frame number decoded
+    long                 s32InBufferLength;           //!< Size (in bytes) of input frame
+    void                *pvAVCData;                   //!< Ptr to Decoder datastructure
+    sAVCDConfigInfo      sConfig;                     //!< Config Info of the bitstream
+    sAVCDMemAllocInfo    sMemInfo;                    //!< Memory Configuration structure
+    sAVCDYCbCrStruct     sFrameData;                  //!< Output pointer where decoded frame
+                                                      //!< is to be written.
+    int                  paf;
+    unsigned char        u8Status;                    //!<flag indicating decoding status
+	void                *pAppContext;                 //!< application data pointer //DSPhl27777
+
+    // Call Back Function
+    int   (*cbkAVCDBufRead)  (unsigned char *pu8Buf, int s32BufLen ,
+                              int *s32Last, void *pAppContext); //DSPhl27777
+
+
+}
+sAVCDecoderConfig;
+/**************************************************
+ * Direct rendering type and data structure
+ **************************************************/
+//typedef void* (*bufferGetter)(void* /*pvAppContext*/);
+//typedef void (*bufferRejecter)(void* /*mem_ptr*/, void* /*pvAppContext*/);
+typedef struct _AVCD_FrameManager
+{
+    bufferGetter BfGetter;
+    bufferRejecter BfRejector;
+}AVCD_FrameManager;
+/**************************************************
+ * Deblock type
+ **************************************************/
+typedef enum
+{
+	E_AVCD_SW_DEBLOCK = 0,
+	E_AVCD_HW_DEBLOCK,
+}eAVCDDeblockOption;
+
+/* Visibility declaration when building and using dynamic library
+ * 1. Microsoft Visual Studio
+ *    Use __declspec(dllexport) and __declspec(dllimport)
+ * 2. armcc
+ *    Same as 1
+ * 3. gcc
+ *    Use __attribute__((visibility("default"))), and compile option -fvisibility=hidden
+ *
+ */
+#if defined(EXPORT_DLL)
+#if defined(MY__GNUC__)
+#define _FSL_EXPORT_C __attribute__((__visibility__("default")))
+#else // end of MY__GNUC__
+#if !defined(ARMCC) && !defined(WINCE_COMPILE) && !defined(MSVC)
+#pragma message("Warning: unspecified compiler type. Using default visibility syntax")
+#endif
+#define _FSL_EXPORT_C __declspec(dllexport)
+
+#endif // end of MSVC and ARMCC
+
+#elif defined(IMPORT_DLL)
+#if defined(MY__GNUC__)
+#define _FSL_EXPORT_C __attribute__((__visibility__("default")))
+#else // end of MY__GNUC__
+#if !defined(ARMCC) && !defined(WINCE_COMPILE) && !defined(MSVC)
+#pragma message("Warning: unspecified compiler type. Using default visibility syntax")
+#endif
+#define _FSL_EXPORT_C __declspec(dllimport)
+
+#endif // end of MSVC and ARMCC
+
+#else // end of IMPORT_DLL
+#define _FSL_EXPORT_C
+#endif // end of ! IMPORT_DLL and ! EXPORT_DLL
+
+    /*! Function to query memory requrement of the decoder */
+    _FSL_EXPORT_C eAVCDRetType   eAVCDInitQueryMem(sAVCDMemAllocInfo *psMemPtr);
+
+    /*! Function to Re-query memory requrement of the decoder */
+    _FSL_EXPORT_C eAVCDRetType   eAVCDReQueryMem (sAVCDecoderConfig *psAVCDec);
+
+    /*! Function to initialize the decoder */
+    _FSL_EXPORT_C eAVCDRetType   eAVCDInitVideoDecoder(sAVCDecoderConfig *psAVCDec);
+
+    /*! API to decode single frame of the encoded bitstream */
+    _FSL_EXPORT_C eAVCDRetType   eAVCDecodeNALUnit(sAVCDecoderConfig *psAVCDec, unsigned char u8FastFwd);
+
+//DSPhl28316-begin
+
+	/*! Function to flush the final frames , if any */
+	_FSL_EXPORT_C eAVCDRetType   eAVCDecoderFlushAll(sAVCDecoderConfig *psAVCDec);
+
+//DSPhl28316-end
+
+    /*! Function to free the resources allocated by decoder, if any */
+    _FSL_EXPORT_C eAVCDRetType   eAVCDFreeVideoDecoder(sAVCDecoderConfig *psAVCDec);
+
+
+    _FSL_EXPORT_C void eAVCDGetFrame( sAVCDecoderConfig *vdec );
+
+
+// Interfaces implemented by framework
+typedef int (*cbkAVCDPrefetchNAL)(unsigned char **pbuf, int *len, void* /*pvAppContext*/);
+typedef void (*cbkAVCDLengthSetter)(int len_after_destuff, void* /*pvAppContext*/);
+typedef struct _NAL_FUNC
+{
+	cbkAVCDPrefetchNAL NALFetcher;
+	cbkAVCDLengthSetter NALLengthSetter;
+}sAVCDNAL_FUNCs;
+_FSL_EXPORT_C void eAVCDSetNALFuncs( sAVCDNAL_FUNCs *NalFuncs );
+/**************************************************
+ * Direct rendering API function
+ **************************************************/
+/*! \brief
+ *        Set the Frame manager to decoder
+ */
+_FSL_EXPORT_C void AVCDSetBufferManager (sAVCDecoderConfig *psAVCDec, AVCD_FrameManager* manager);
+
+// new api format to support additional callback such as release,...
+//typedef void (*bufferReleaser)(void* /*mem_ptr*/, void* /*pvAppContext*/);
+typedef unsigned int (*queryPhysicalAddr)(void* /*virt_ptr*/, void* /*pvAppContext*/);
+
+//typedef enum
+//{
+// E_GET_FRAME =0,
+// E_REJECT_FRAME,
+// E_RELEASE_FRAME,
+// E_QUERY_PHY_ADDR,
+//} eCallbackType; //add this to indicate additional callback function type.
+
+//typedef enum
+//{
+// E_CB_SET_OK =0,
+// E_CB_SET_FAIL,
+//} eCallbackSetRet; //add this to indicate additional callback function type.
+
+_FSL_EXPORT_C eCallbackSetRet H264SetAdditionalCallbackFunction (sAVCDecoderConfig *psAVCDec, eCallbackType funcType, void* cbFunc);
+
+
+/**************************************************
+ * Deblock type set/get API functions
+ **************************************************/
+/*! \brief
+ *        Set the SW/HW deblock option
+ */
+_FSL_EXPORT_C void AVCDSetDeblockOption(sAVCDecoderConfig *psAVCDec, eAVCDDeblockOption deblockOption);
+/*! \brief
+ *        Get the SW/HW deblock option
+ */
+_FSL_EXPORT_C eAVCDDeblockOption AVCDGetDeblockOption(sAVCDecoderConfig *psAVCDec);
+
+_FSL_EXPORT_C const char * H264DCodecVersionInfo();
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
--- /dev/null
+++ gst-fsl-plugins-3.0.7/inc/core_lib/wma8_enc_interface.h
@@ -0,0 +1,201 @@
+
+/*
+* Copyright (c) 2005-2009, 2013 Freescale Semiconductor, Inc. 
+ */
+
+/*
+* This library is free software; you can redistribute it and/or
+* modify it under the terms of the GNU Lesser General Public
+* License as published by the Free Software Foundation; either
+* version 2.1 of the License, or (at your option) any later version.
+*
+* This library is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* Lesser General Public License for more details.
+*
+* You should have received a copy of the GNU Lesser General Public
+* License along with this library; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+ 
+ /***************************************************************************
+ *   CHANGE HISTORY
+ *   dd/mm/yy        Code Ver     Description             Author
+ *   --------        -------      -----------             ------
+ *   23/10/07         0.1 	      created file            Jackie Yin.
+ **************************************************************************/
+#ifndef __WMAE_ENC_INTERFACE_H_
+#define __WMAE_ENC_INTERFACE_H_
+#define WMAE_TRUE               1
+#define WMAE_FALSE              0
+//***********************************************************************
+//   Data type 
+//***********************************************************************
+typedef unsigned char		  WMAE_UINT8;
+typedef char			        WMAE_INT8;
+typedef unsigned short		WMAE_UINT16;
+typedef short		        	WMAE_INT16;
+typedef unsigned int		  WMAE_UINT32;
+typedef int			          WMAE_INT32;
+typedef WMAE_UINT32       WMAE_Bool;
+#if _WIN32
+typedef unsigned __int64        WMAE_UINT64;
+typedef __int64                 WMAE_INT64;
+#else
+typedef unsigned long long      WMAE_UINT64;
+typedef long long               WMAE_INT64;
+#endif
+
+/* status */
+#ifndef _WMAENCODESTATUS_DEFINED
+#define _WMAENCODESTATUS_DEFINED
+
+typedef enum tagWMAEncodeStatus
+{
+    WMA_Succeeded = 0,
+    WMA_Failed,
+    WMA_BadMemory,
+    WMA_NoMoreFrames,
+    WMA_EncodeFailed,
+    WMA_UnSupportedInputFormat,
+    WMA_UnSupportedCompressedFormat,
+    WMA_InValidArguments,
+    WMA_BadSource,
+} tWMAEncodeStatus;
+#endif
+
+//***********************************************************************
+//  memory definition
+//***********************************************************************
+#define WMAE_FAST_MEMORY                  1
+#define WMAE_SLOW_MEMORY                  0
+#define WMAE_MAX_NUM_MEM_REQS             1 // (Temporary)
+#define WMAE_MEM_TYPE                     WMAE_FAST_MEMORY /* can be changed */
+#define STRING_SIZE 512		     //Really long name also will be taken care of
+#define MAX_METADATA_CHARS 255 // Max length of Metadata in chars
+#define NUMPACKET 4
+#define MAX_PACKET_BYTE_LENGTH 1372*7 //WMA packet size. Should be multiple integer of 1372
+
+//***********************************************************************
+//  enum definition
+//***********************************************************************
+typedef enum
+{
+    WMAE_STATIC_MEM,        /* 0 for static memory */
+    WMAE_SCRATCH_MEM        /* 1 for scratch memory */
+} WMAE_MEM_DESC;
+
+//***********************************************************************
+//  struct definition
+//***********************************************************************
+
+#ifdef __arm
+#define EMBARM_PACK __packed
+#else
+#define EMBARM_PACK
+#endif
+
+#ifndef _WAVEFORMATEX_
+#define _WAVEFORMATEX_
+#pragma pack(push,1)
+#ifdef _LINUX_BUILD_ 
+typedef struct
+#else
+typedef EMBARM_PACK struct
+#endif
+{
+    WMAE_UINT16     wFormatTag;        /* format type */
+    WMAE_UINT16     nChannels;         /* number of channels (i.e. mono, stereo...) */
+    WMAE_UINT32     nSamplesPerSec;    /* sample rate */
+    WMAE_UINT32     nAvgBytesPerSec;   /* for buffer estimation */
+    WMAE_UINT16     nBlockAlign;       /* block size of data */
+    WMAE_UINT16     wBitsPerSample;    /* Number of bits per sample of mono data */
+    WMAE_UINT16     cbSize;            /* The count in bytes of the size of
+                                        * extra information (after cbSize) */
+} WAVEFORMATEX, *PWAVEFORMATEX, *LPWAVEFORMATEX;
+#pragma pack(pop)
+#endif
+
+typedef struct {
+    WMAE_INT32	    s32WMAESize;     /* Size in bytes */
+    WMAE_INT32 	    s32WMAEType;     /* Memory type Fast or Slow */
+    WMAE_MEM_DESC   s32WMAEMemDesc;  /* to indicate if it is scratch memory */
+    WMAE_INT32      s32WMAEPriority; /* In case of fast memory, specify the priority */
+    void 	          *app_base_ptr;   /* Pointer to the base memory , which will be allocated and
+                                      * filled by the  application */
+} WMAEMemAllocInfoSub;
+
+typedef struct {
+    WMAE_INT32              s32NumReqs;
+    WMAEMemAllocInfoSub	    sMemInfoSub [WMAE_MAX_NUM_MEM_REQS];
+} WMAEMemAllocInfo;
+
+#ifndef _STRUCT_WMAFORMATINFO_
+#define _STRUCT_WMAFORMATINFO_
+typedef struct 
+{
+    // base WAVEFORMATEX
+    WMAE_UINT32 nSamplesPerSec;
+    WMAE_UINT32 nChannels;
+    WMAE_UINT32 nAvgBytesPerSec;
+    WMAE_UINT32 nBlockAlign;
+    // extended WAVEFORMATES
+    WMAE_UINT32 nSamplesPerBlock;
+    WMAE_UINT32 dwSuperBlockAlign;
+    WMAE_UINT16 wEncodeOptions;
+    // miscellaneous
+    WMAE_UINT32 nFramesPerPacket;
+    WMAE_UINT32 nSamplesPerFrame;
+    WMAE_UINT32 nMaxSamplesPerPacket;
+    WMAE_UINT32 nLookaheadSamples;
+    WMAE_UINT32 nSuperFrameSamples; // useless ?
+    WMAE_UINT32 ulOfficialBitrate;
+    WMAE_INT64  nAudioDelaySizeMs;  
+} WMAFormatInfo;
+#endif
+#ifndef _STRUCT_WMAEENCODERPARAMS_
+#define _STRUCT_WMAEENCODERPARAMS_
+typedef struct
+{
+  void * App_szInputFileName;                 // input wav file name
+  void * App_szOutputFileName;                // output wma file name
+  WAVEFORMATEX	*App_pAudioInput;		      // audio input settings
+  WMAE_UINT32   App_iAudioSrcLength;		  // length of the audio source
+  WMAE_UINT32   App_iDstAudioBitRate;		  // audio output bitrate
+  WMAE_UINT32   App_iDstAudioSampleRate;	// audio output sample rate
+  WMAE_UINT32   App_iDstAudioChannels;		// audio output channel count
+                                          //wma encoder variables here 
+  WMAE_UINT32 WMAE_packet_byte_length;
+  WMAE_Bool   WMAE_isPacketReady;
+  WMAE_UINT32 WMAE_nEncodeSamplesDone;
+  WMAFormatInfo pFormat;  
+  
+}WMAEEncoderParams;
+#endif
+
+typedef struct
+{
+  WMAEMemAllocInfo		 sWMAEMemInfo;
+  void			          *psWMAEncodeInfoStructPtr; // Global_struct
+  WMAEEncoderParams		*psEncodeParams; //for Encoder Params
+}WMAEEncoderConfig;
+
+#ifdef __cplusplus
+#define EXTERN extern "C"
+#else
+#define EXTERN 
+#endif
+
+EXTERN tWMAEncodeStatus eWMAEQueryMem( WMAEEncoderConfig *psEncodeConfig);
+
+EXTERN tWMAEncodeStatus eInitWMAEncoder( WMAEEncoderConfig *psEncodeConfig );
+                                
+EXTERN tWMAEncodeStatus eWMAEncodeFrame( WMAEEncoderConfig* psEncodeConfig,
+													      WMAE_INT16 *pInputBuffer,
+                                WMAE_INT8 *pOutputBuffer,
+                                WMAE_Bool bNoMoreData);
+
+EXTERN const char * WMA8ECodecVersionInfo();
+
+#endif
--- /dev/null
+++ gst-fsl-plugins-3.0.7/inc/core_lib/nb_amr_dec_api.h
@@ -0,0 +1,159 @@
+
+/*
+* Copyright (c) 2004-2010, 2013, Freescale Semiconductor, Inc. 
+*/
+
+/*
+* This library is free software; you can redistribute it and/or
+* modify it under the terms of the GNU Lesser General Public
+* License as published by the Free Software Foundation; either
+* version 2.1 of the License, or (at your option) any later version.
+*
+* This library is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* Lesser General Public License for more details.
+*
+* You should have received a copy of the GNU Lesser General Public
+* License along with this library; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+/********************************************************************************
+* File Name: nb_amr_dec_api.h
+*
+* Description: This is a header file for nb_amr_dec_api.c.
+*/
+
+/****************************** Change History***********************************
+*
+*   DD/MMM/YYYY     Code Ver     Description      Author
+*   -----------     --------     -----------      ------
+*   20/May/2004     0.1          File created     Ashok
+*   03/Jun/2004     1.0          Review rework    Ashok
+*   22/Jul/2004     1.1          Clened up code    Ashok
+*   01/Jul/2008     1.2          Added version    Tao Jun
+*                                API
+*******************************************************************************/
+#ifndef NB_AMR_DEC_API_H
+#define NB_AMR_DEC_API_H
+
+/*****************************<INCLUDE_FILES BEGIN>****************************/
+#ifndef _OS_VRTX
+#include <stdio.h>
+#endif
+#include "nb_amr_common_api.h"
+/*******************************<INCLUDE_FILES END>****************************/
+
+/******************************<DEFINES BEGIN>*********************************/
+
+/* this define should be set to non-zero val to enable debug log
+ * Following are the value and corresponding enabling
+ * 0x0 -> log disbale
+ * 0x1 -> log level 0 enable
+ * 0x2 -> log level 1 will get enabled
+ * 0x3 -> 0 and 1 both will get enabled
+ * 0x4 -> log level 2 will be enabled
+ * 0xf -> all log level will be enabled
+ */
+
+#define NBAMRD_DBGLOG_LVL 0x0
+
+/* start val of debug log msg id */
+#define NBAMRD_BEGIN_DBGLOG_MSGID  400
+/* end of debug log message */
+#define NBAMRD_END_DBGLOG_MSGID  499
+/******************************<DEFINES END>***********************************/
+
+/******************************<ENUMS BEGIN>***********************************/
+/* Success is assigned to 0. As of now there can be 20 warnings,
+   starting from 11 to 30. Recoverable errors can be 20,
+   starting from 31 to 50. Fatal errors can be 20, starting
+   from 51 to 70. Later more error types can be added */
+
+/***** Decoder return type, other return value to be added ****/
+typedef enum
+{
+     E_NBAMRD_OK =0,
+     E_NBAMRD_WARNING = NBAMR_WARNING_BASE,
+     E_NBAMRD_INVALID_MODE = NBAMR_RECOVERROR_BASE,
+     E_NBAMRD_INIT_ERROR,
+     E_NBAMRD_INVALID_DECODER_ARGS,
+     E_NBAMRD_INVALID_BITSTREAM,
+     E_NBAMRD_INPUT_READERROR,
+     E_NBAMRD_MEMALLOC_ERROR = NBAMR_FATALERROR_BASE,
+     E_NBAMRD_ERROR
+} eAMRDReturnType;
+
+/******************************<ENUMS END>*************************************/
+
+/****************************<STRUCTURES/UNIONS BEGIN>*************************/
+/* decoder sub-memory array */
+typedef struct
+{
+	NBAMR_S32	s32AMRDSize;	  /* Size in bytes */
+	NBAMR_S32 	s32AMRDMemType;	  /* Memory is STATIC or SCRATCH */
+	NBAMR_S32 	s32AMRDMemTypeFs; /* Memory type FAST or SLOW */
+	NBAMR_Void	*pvAPPDBasePtr;	  /* Pointer to the base memory,
+	                               which will be allocated
+ 						           and filled by the application*/
+	NBAMR_U8	u8AMRDMemPriority; /* Priority level */
+
+} sAMRDMemAllocInfoSubType;
+
+/* decoder memory info structure */
+typedef struct
+{
+	/* Number of valid memory requests */
+	NBAMR_S32				s32AMRDNumMemReqs;
+	sAMRDMemAllocInfoSubType 	asMemInfoSub[NBAMR_MAX_NUM_MEM_REQS];
+}sAMRMemAllocInfoType;
+
+/* decoder parameter structure */
+typedef struct
+{
+	sAMRMemAllocInfoType  sAMRDMemInfo;
+	NBAMR_Void           *pvAMRDDecodeInfoPtr;
+    NBAMR_U8             *pu8APPDInitializedDataStart;
+    NBAMR_U8             u8RXFrameType;        /* whether frame is contains RX frame */
+    NBAMR_U8             u8BitStreamFormat;    /* Requested file format */
+    NBAMR_U8             u8NumFrameToDecode;    /* number of frame to be decoded */
+    NBAMR_U8             watermarkFlag;         /* watermark Flag for codec protection */
+}sAMRDDecoderConfigType;
+/****************************<STRUCTURES/UNIONS END>***************************/
+
+/***************************<GLOBAL_VARIABLES BEGIN>***************************/
+                                   /* None */
+/***************************<GLOBAL_VARIABLES END>*****************************/
+                                   /* None */
+/**************************<STATIC_VARIABLES BEGIN>****************************/
+                                    /* None */
+/**************************<STATIC_VARIABLES END>******************************/
+
+/**************************<FUNCTION_PROTOTYPES BEGIN>*************************/
+#ifdef __SYMBIAN32__
+#define EXTERN
+#define EXPORT_C __declspec(dllexport)
+#else
+#define EXTERN
+#define EXPORT_C
+#endif
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+  eAMRDReturnType eAMRDDecodeInit (sAMRDDecoderConfigType *psDecConfig);
+
+  eAMRDReturnType eAMRDDecodeFrame (sAMRDDecoderConfigType *psDecConfig,
+			NBAMR_S16 *ps32InBuf, NBAMR_S16 *ps32OutBuf);
+
+  eAMRDReturnType eAMRDQueryMem (sAMRDDecoderConfigType *psDecConfig);
+
+  const char * eAMRDVersionInfo(void);
+#ifdef __cplusplus
+}
+#endif
+/**************************<FUNCTION_PROTOTYPES END>***************************/
+
+#endif /* end of NB_AMR_DEC_API_H header file */
+/**************************<END OF THE FILE>***********************************/
--- /dev/null
+++ gst-fsl-plugins-3.0.7/inc/core_lib/wbamr_dec_interface.h
@@ -0,0 +1,142 @@
+
+/*
+* Copyright (c) 2004-2010, 2013, Freescale Semiconductor, Inc. 
+*/
+
+/*
+* This library is free software; you can redistribute it and/or
+* modify it under the terms of the GNU Lesser General Public
+* License as published by the Free Software Foundation; either
+* version 2.1 of the License, or (at your option) any later version.
+*
+* This library is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* Lesser General Public License for more details.
+*
+* You should have received a copy of the GNU Lesser General Public
+* License along with this library; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+/************************************************************************
+*
+* File Name			: WBAMR_DEC_INTERFACE.H
+*
+* Description		: WBAMR Decoder interface.
+*
+* Functions Included: --NONE--
+*
+****************************** Change History**************************
+*
+*    DD/MM/YYYY     Code Ver     Description      Author
+*    -----------     --------     -----------      ------
+*	 03/11/2004		1.0			Initial version		Shashi/Naganna
+**********************************************************************/
+
+#ifndef _WBAMR_DEC_INTERFACE_H_
+#define	_WBAMR_DEC_INTERFACE_H_
+
+#include "wbamr_common_interface.h"
+#include <stdio.h>
+#include <stdlib.h>
+
+/* this should be set to 0xF to enable all the debug level logs
+ * value of 0x1 will enbale - log level 1 only
+ * value of 0x2 will enable - log level 2 only
+ * value of 0x3 will enable - level 1 and 2 logs
+ * value of 0x4 will enable - level 3 logs
+ * value of 0x8 will enabel - level 4 log
+ */
+#define WBAMRD_DEBUG_LVL 0x0
+
+/* this is start of log message */
+#define WBAMRD_BEGIN_DBG_MSGID  300
+/* end of debug msg id */
+#define WBAMRD_END_DBG_MSGID    600
+
+#define BEGIN_WBAMRD_DATA		NULL		/* to be decided by
+							application */
+/***************** Data types ************************************/
+#define WBAMRD_NUM_WARNING 20
+#define WBAMRD_NUM_RECOVERROR 20
+#define WBAMRD_WARNING_BASE 111
+#define WBAMRD_RECOVERROR_BASE (WBAMRD_NUM_WARNING+WBAMRD_WARNING_BASE)
+#define WBAMRD_FATALERROR_BASE (WBAMRD_RECOVERROR_BASE+WBAMRD_NUM_RECOVERROR)
+
+
+/***** Decoder return type, other return value to be added ****/
+/* Success is assigned to 0. As of now there can be 20 warnings, starting from 111 to 130.
+Recoverable errors can be 20, starting from 131 to 150. Fatal errors can be 20, starting from 151 to 170. Later more error types can be added */
+
+typedef enum
+{
+     WBAMRD_OK,
+     WBAMRD_WARNING = WBAMRD_WARNING_BASE,			/* Warning */
+     WBAMRD_INVALID_MODE = WBAMRD_RECOVERROR_BASE,	/* Recoverable error */
+     WBAMRD_INIT_ERROR,								/* Recoverable error */
+     WBAMRD_MEMALLOC_ERROR = WBAMRD_FATALERROR_BASE/* Fatal error */
+} WBAMRD_RET_TYPE;
+
+/* received speech frame enum */
+typedef enum
+{
+	 WBAMRD_RX_SPEECH_GOOD = 0,
+     WBAMRD_RX_SPEECH_PROBABLY_DEGRADED,
+     WBAMRD_RX_SPEECH_LOST,
+     WBAMRD_RX_SPEECH_BAD,
+     WBAMRD_RX_SID_FIRST,
+     WBAMRD_RX_SID_UPDATE,
+     WBAMRD_RX_SID_BAD,
+     WBAMRD_RX_NO_DATA,
+     WBAMRD_RX_N_FRAMETYPES							/* number of frame types */
+} WBAMRD_RXFrameType;
+
+/******************** Structure/Union ***************************/
+/* decoder sub-memory array */
+typedef struct
+{
+	WBAMR_S32		wbamrd_size;				/* Size in bytes */
+	WBAMRMemType 	wbamrd_mem_type;  			/* Static or scratch */
+	WBAMR_S32 		wbamrd_type_fs;				/* Fast or Slow */
+	WBAMR_U8 		wbamrd_priority;			/* Priority level */
+	void			*wbappd_base_ptr;			/* Pointer to the base memory, which will be
+												   allocated and filled by the application*/
+}WBAMRD_Mem_Alloc_Info_Sub;
+
+/* decoder memory info structure */
+typedef struct
+{
+	WBAMR_S32					wbamrd_num_reqs;/* Number of valid memory requests */
+	WBAMRD_Mem_Alloc_Info_Sub 	mem_info_sub[WBAMR_MAX_NUM_MEM_REQS];
+}WBAMRD_Mem_Alloc_Info;
+
+/* decoder parameter structure */
+typedef struct
+{
+	WBAMRD_Mem_Alloc_Info     wbamrd_mem_info;
+	void				      *wbamrd_decode_info_struct_ptr;
+    WBAMR_U8                  *wbappd_initialized_data_start;
+    WBAMR_U8                  bitstreamformat;
+    WBAMR_U8                  watermarkFlag;
+}WBAMRD_Decoder_Config;
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+ WBAMRD_RET_TYPE wbamrd_query_dec_mem(WBAMRD_Decoder_Config *dec_config);
+
+ WBAMRD_RET_TYPE wbamrd_decode_init (WBAMRD_Decoder_Config *dec_config);
+
+ WBAMRD_RET_TYPE wbamrd_decode_frame (WBAMRD_Decoder_Config *dec_config,
+				WBAMR_S16 *in_buf,
+				WBAMR_S16 *out_buf);
+ const char *WBAMR_get_version_info(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- /dev/null
+++ gst-fsl-plugins-3.0.7/inc/core_lib/asf.h
@@ -0,0 +1,340 @@
+/*
+* Copyright (c) 2007-2013, Freescale Semiconductor, Inc. 
+ */
+
+/*
+* This library is free software; you can redistribute it and/or
+* modify it under the terms of the GNU Lesser General Public
+* License as published by the Free Software Foundation; either
+* version 2.1 of the License, or (at your option) any later version.
+*
+* This library is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* Lesser General Public License for more details.
+*
+* You should have received a copy of the GNU Lesser General Public
+* License along with this library; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef _ASF_H_
+#define _ASF_H_
+
+#define ASF_HEADER sizeof(struct s_asf_packet_header_type)
+
+
+/* status */
+#ifndef _ASFRESULTS_DEFINED
+#define _ASFRESULTS_DEFINED
+typedef enum tagASFResults
+{
+    cASF_NoErr,                 /* -> always first entry */
+                                /* remaining entry order is not guaranteed */
+    cASF_Failed,
+    cASF_BadArgument,
+    cASF_BadAsfHeader,
+    cASF_BadPacketHeader,
+    cASF_BrokenFrame,
+    cASF_NoMoreFrames,
+}ASFRESULTS;
+#endif
+
+
+//***********************************************************************
+//   Data type 
+//***********************************************************************
+typedef unsigned char           ASF_UINT8;
+typedef char                    ASF_INT8;
+typedef unsigned short          ASF_UINT16;
+typedef short		            ASF_INT16;
+typedef unsigned int            ASF_UINT32;
+typedef int                     ASF_INT32;
+typedef ASF_UINT32              ASF_Bool;
+
+#if _WIN32
+typedef unsigned __int64        ASF_UINT64;
+typedef __int64                 ASF_INT64;
+#else
+typedef unsigned long long      ASF_UINT64;
+typedef long long               ASF_INT64;
+#endif
+
+
+
+typedef unsigned char byte;
+typedef unsigned short word;
+typedef unsigned long long qword;
+
+#ifndef _STRUCT_ASF_PACKET_
+#define _STRUCT_ASF_PACKET_
+
+#if ((defined(TGT_OS_LERVDS) || defined(TGT_OS_ELINUX))) && (defined(__arm))
+#define PACKED  __packed
+#else
+#define PACKED  
+#pragma pack(push,1)
+#endif
+
+typedef PACKED struct 
+{ 
+#ifdef UNDER_CE        
+        char reserved[16];
+#else
+        byte reserved[16];
+#endif  
+  qword len;
+} id_size_t;
+
+typedef PACKED struct s_asf_header_type {
+
+    // Header Object
+    PACKED struct s_header_obj {
+        id_size_t header;  
+        byte cno[4];  
+        byte v1;  
+        byte v2;
+    } header_obj;                       
+
+    // File Properties Object
+   PACKED struct s_file_obj {
+        id_size_t fheader;
+        byte file_id[16];
+        byte file_size[8];
+        byte creation_time[8];
+        byte num_packets[8];
+        byte play_duration[8];
+        byte send_duration[8];
+        byte preroll[8];
+        byte flags[4];
+        byte min_packet_size[4];
+        byte max_packet_size[4];
+        byte max_bitrate[4];
+    } file_obj;                    
+
+    // Stream Properites Object
+    PACKED struct s_stream_obj {
+        id_size_t sheader;
+        byte     stream_type[16];
+        byte     concealment[16];
+        byte     time_offset[8];
+        byte     type_size[4];
+        byte     error_corr_size[4];
+        byte     stream_num[2];
+        byte     reserved1[4];
+
+        PACKED struct s_audio_media {   // Specific data: Audio Media Type
+            byte codec_id[2];
+            byte channel_num[2];
+            byte samples_per_sec[4];
+            byte bytes_per_sec[4];
+            byte block_alignment[2];
+            byte bits_per_sample[2];
+            byte codec_specific_size[2];
+            byte samples_per_block[4];
+            byte encode_options[2];
+            byte super_block_align[4];
+        } audio_media;
+
+        PACKED struct s_spread_audio {       // Error Correction Data: Spread Audio
+            byte span;
+            byte virtual_packet_len[2];
+            byte virtual_chunk_len[2];
+            byte silence_data_len[2];
+            byte silence_data;
+        } spread_audio;
+    } stream_obj;
+
+    // Header Extension Object
+    PACKED struct s_ext_obj {
+        id_size_t extheader;
+#ifdef UNDER_CE        
+        char reserved[16];
+#else
+        byte reserved[16];
+#endif        
+        byte unknown[2];
+        byte length[4];
+    } ext_obj;
+
+    // Codec List Object
+    PACKED struct s_codec_obj {
+        id_size_t codecheader;
+        byte codec_reserved[16];
+        byte entries_num[4];
+        byte codec_type[2];
+        byte codec_name_len[2];
+        word codec_name[26];
+        byte codec_descript_len[2];
+        word codec_descript[26];
+        byte codec_info_len[2];
+        byte codec_info[2];
+    } codec_obj;  
+
+    // Content Description Object
+    // This structure does not include the actual
+    // content description fields (title, author...)
+    PACKED struct s_cont_desc_obj {
+        id_size_t contdescheader;
+        word      title_len;
+        word      author_len;
+        word      copyright_len;
+        word      description_len;
+        word      rating_len;
+    } cont_desc_obj;
+
+    // Data Object
+    PACKED struct s_data_obj {
+        id_size_t dataheader;
+        byte file_id[16];
+        byte num_data_packets[8];
+        byte reserved[2];    /* reserved the value shall be 0x11 */
+    } data_obj;
+
+} asf_header_type;
+
+
+typedef PACKED struct s_asf_packet_header_type {
+    byte error_corr_flags;
+    byte error_corr_data[2];
+    byte length_type_flags;
+    byte property_flags;
+    byte padding_length[2];
+    byte send_time[4];
+    byte duration[2];
+    byte stream_id;
+    byte media_obj_id;
+    byte offset[4];
+    byte replicated_len;
+    byte media_obj_size[4];
+    byte pres_time[4];
+} asf_packet_header_type;
+#ifndef __arm
+#pragma pack(pop)
+#endif
+#endif
+
+#ifndef _STRUCT_ASFFORMATINFO_
+#define _STRUCT_ASFFORMATINFO_
+typedef struct 
+{
+    // base WAVEFORMATEX
+    ASF_UINT32 nSamplesPerSec;
+    ASF_UINT32 nChannels;
+    ASF_UINT32 nAvgBytesPerSec;
+    ASF_UINT32 nBlockAlign;
+    // extended WAVEFORMATES
+    ASF_UINT32 nSamplesPerBlock;
+    ASF_UINT32 dwSuperBlockAlign;
+    ASF_UINT16 wEncodeOptions;
+    // miscellaneous
+    ASF_UINT32 nFramesPerPacket;
+    ASF_UINT32 nSamplesPerFrame;
+    ASF_UINT32 nMaxSamplesPerPacket;
+    ASF_UINT32 nLookaheadSamples;
+    ASF_UINT32 nSuperFrameSamples; // useless ?
+    ASF_UINT32 ulOfficialBitrate;
+    ASF_INT64  nAudioDelaySizeMs;  
+} ASFFormatInfo;
+#endif
+
+typedef struct
+{
+  asf_header_type asf_header;
+  ASF_INT32 media_offset;
+  ASF_INT64 asf_packet_count;
+  ASF_UINT8 wma_packet_id;
+  ASF_INT64 wma_packet_count;
+  ASF_INT64 asf_file_size;
+  
+  ASF_INT32 nAudioSampleperSec;
+  ASF_INT32 nMaxBitRate;
+  ASF_INT64 nSendTime;
+  ASF_INT16 nDuration;
+  
+  ASF_UINT32 WMAE_packet_byte_length;
+  ASF_INT32  g_asf_packet_size;
+  ASF_INT32  g_asf_payload_length;
+
+  ASF_UINT32 g_space_in_packet;
+  
+  ASF_UINT16 *g_wszTitle;        // Cont Desc: Title
+  ASF_UINT16 *g_wszAuthor;       // Cont Desc: Author
+  ASF_UINT16 *g_wszCopyright;    // Cont Desc: Copyright
+  ASF_UINT16 *g_wszDescription;  // Cont Desc: Description
+  ASF_UINT16 *g_wszRating;       // Cont Desc: Rating
+  
+  ASF_UINT16 g_cTitle;              // length of Title
+  ASF_UINT16 g_cAuthor;             // length of Author
+  ASF_UINT16 g_cCopyright;          // length of Copyright
+  ASF_UINT16 g_cDescription;        // length of Description
+  ASF_UINT16 g_cRating;             // length of Rating
+  
+  ASF_INT64 nAudioDelayBuffer;
+  ASF_INT64 presentation_time; 
+  ASF_INT64 nAudioSamplesDone;
+  ASF_UINT32 nSize,nSR;  
+  ASFFormatInfo pFormat; 
+}ASFParams;
+
+#define SWAP_WORD( w )    (w) = (((w) & 0xFF ) << 8) | (((w) & 0xFF00 ) >> 8)
+#define SWAP_DWORD( dw )  (dw) = ((dw) << 24) | ( ((dw) & 0xFF00) << 8 ) | ( ((dw) & 0xFF0000) >> 8 ) | ( ((dw) & 0xFF000000) >> 24);
+
+#define ASFPUT8(slot, val) {        \
+  char *dst =(char *) slot;         \
+  *dst++ = (char)((val));           \
+  *dst++ = (char)((val)>> 8);       \
+  *dst++ = (char)((val)>>16);       \
+  *dst++ = (char)((val)>>24);       \
+  *dst++ = (char)((val)>>32);       \
+  *dst++ = (char)((val)>>40);       \
+  *dst++ = (char)((val)>>48);       \
+  *dst++ = (char)((val)>>56); }
+
+#define ASFPUT4(slot, val) {        \
+  char *dst = (char *) slot;        \
+  *dst++ = (char)((val));           \
+  *dst++ = (char)((val)>> 8);       \
+  *dst++ = (char)((val)>>16);       \
+  *dst++ = (char)((val)>>24); }
+
+#define ASFPUT2(slot, val) {        \
+  char *dst =(char *) slot;         \
+  *dst++ = (char)((val));           \
+  *dst++ = (char)((val)>>8); }
+
+#ifdef L_ENDIAN
+
+#define ASF_2(  word )  (word)
+#define ASF_4( dword ) (dword)
+#define ASF_8( qword ) (qword)
+
+#else
+
+// these may require modification depending
+// upon your big-endian memory layout. the
+// values need to be written out in little-
+// endian.
+
+#define ASF_2(  word )  SWAP_WORD(  word )
+#define ASF_4( dword ) SWAP_DWORD( dword )
+#define ASF_8( qword ) ( ( SWAP_DWORD( qword >> 32 ) << 32 ) \
+                         | SWAP_DWORD( qword & 0xffffffff ) )
+#endif
+
+
+#ifdef __cplusplus
+#define EXTERN extern "C"
+#else
+#define EXTERN 
+#endif
+//void asf_packetize(ASFParams *pAsfParams,char *outBuf);
+//void update_asf_file_header(ASFParams *pAsfParams, char *outBuf);
+EXTERN ASFRESULTS write_asf_file_header ( ASFParams *pAsfParams,ASF_INT8* buf);
+EXTERN ASFRESULTS update_asf_file_header(ASFParams *pAsfParams,ASF_UINT32 kbps,ASF_UINT32 kHz,ASF_UINT32 ch,ASF_UINT16 nBlockAlign,ASF_INT32 cFrameSize);
+EXTERN ASF_INT32 add_asf_file_header (ASFParams *pAsfParams);
+EXTERN ASFRESULTS asf_packetize (ASFParams *pAsfParams,ASF_INT8 *RawInput, ASF_INT8 *asfOutBuf,ASF_Bool WMAE_isPacketReady,ASF_INT32 WMAE_nEncodeSamplesDone);
+#endif
+
+
+
--- /dev/null
+++ gst-fsl-plugins-3.0.7/inc/core_lib/wbamr_common_interface.h
@@ -0,0 +1,116 @@
+
+/*
+* Copyright (c) 2004-2010, 2013, Freescale Semiconductor, Inc. 
+*/
+
+/*
+* This library is free software; you can redistribute it and/or
+* modify it under the terms of the GNU Lesser General Public
+* License as published by the Free Software Foundation; either
+* version 2.1 of the License, or (at your option) any later version.
+*
+* This library is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* Lesser General Public License for more details.
+*
+* You should have received a copy of the GNU Lesser General Public
+* License along with this library; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+/***********************************************************************
+* File Name			: WBAMR_COMMON_INTERFACE.H
+*
+* Description		: Common macros for WBAMR Decoder and Encoder.
+*
+* Functions Included: --NONE--
+*
+****************************** Change History**************************
+*
+*    DD/MM/YYYY     Code Ver     Description      Author
+*    -----------     --------     -----------      ------
+*	 03/11/2004		1.0			Initial version		Shashi/Naganna
+**********************************************************************/
+
+#ifndef _WBAMR_COMMON_INTERFACE_H_
+#define	_WBAMR_COMMON_INTERFACE_H_
+
+#ifdef TGT_OS_VRTX
+#define alloc_fast(x)	MALLOC(x)
+#define alloc_slow(x)	MALLOC(x)
+#else
+#define alloc_fast(x)	malloc(x)
+#define alloc_slow(x)	malloc(x)
+#endif
+
+#ifdef __SYMBIAN32__
+#define EXPORT_C __declspec(dllexport)
+#else
+#define EXPORT_C
+#endif
+
+#define WBAMR_TRUE	         	1
+#define WBAMR_FALSE				0
+#define WBAMR_SUCCESS			0
+#define WBAMR_FAILURE 			1
+#define WBAMR_FAST_MEMORY       0
+#define WBAMR_SLOW_MEMORY       1
+#define WBAMR_MAX_NUM_MEM_REQS	2
+#define WBAMR_MEM_TYPE			WBAMR_FAST_MEMORY
+#define WBAMR_MAX_SERIAL_SIZE	477
+#define WBAMR_SERIAL_FRAMESIZE 	(1+WBAMR_MAX_SERIAL_SIZE+2)
+#define WBAMR_L_FRAME      		320
+
+/* this is start of log message */
+#define WBAMRC_BEGIN_DBG_MSGID  200
+/* end of debug msg id */
+#define WBAMRC_END_DBG_MSGID    299
+
+/* mode 6.60 kbps */
+#define WBAMR_MODE_6_60		0
+
+/* mode 8.85 kbps */
+#define WBAMR_MODE_8_85		1
+/* mode 12.65 kbps */
+#define WBAMR_MODE_12_65	2
+/* mode 14.25 kbps */
+#define WBAMR_MODE_14_25	3
+/* mode 15.85 kbps */
+#define WBAMR_MODE_15_85	4
+/* mode 18.25 kbps */
+#define WBAMR_MODE_18_25	5
+/* mode 19.85 kbps */
+#define WBAMR_MODE_19_85	6
+/* mode 23.05 kbps */
+#define WBAMR_MODE_23_05	7
+/* mode 23.85 kbps */
+#define WBAMR_MODE_23_85	8
+
+
+/********************** Data types ******************************/
+
+/******** define 8 bit signed/unsigned types & constants ********/
+
+typedef signed char WBAMR_S8;
+typedef unsigned char WBAMR_U8;
+
+
+/******** define 16 bit signed/unsigned types & constants *********/
+
+typedef short WBAMR_S16;
+typedef unsigned short WBAMR_U16;
+
+
+/********define 32 bit signed/unsigned types & constants *********/
+
+typedef int WBAMR_S32;
+typedef unsigned int WBAMR_U32;
+
+typedef enum {
+	WBAMR_STATIC,
+	WBAMR_SCRATCH
+}WBAMRMemType;
+
+#endif
+
--- /dev/null
+++ gst-fsl-plugins-3.0.7/inc/core_lib/mp3_enc_interface.h
@@ -0,0 +1,150 @@
+  /*
+* Copyright (c) 2005-2009, 2013, Freescale Semiconductor, Inc. 
+ */
+
+/*
+* This library is free software; you can redistribute it and/or
+* modify it under the terms of the GNU Lesser General Public
+* License as published by the Free Software Foundation; either
+* version 2.1 of the License, or (at your option) any later version.
+*
+* This library is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* Lesser General Public License for more details.
+*
+* You should have received a copy of the GNU Lesser General Public
+* License along with this library; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+/************************************************************************
+* ANSI C source code
+*
+* Project Name : MP3 Encoder
+*
+***************************************************************************/
+/***************************************************************************
+ *   CHANGE HISTORY
+ *   dd/mm/yy   Code Ver     Description                   Author
+ *   --------   -------      -----------                   ------
+ *   Aug 07    0.1 		created file
+ **************************************************************************/
+/*********************************************************************************************
+ *   CHANGE HISTORY
+ *   dd/mm/yy   Code Ver     Description                   Author
+ *   --------   -------      -----------                   ------
+ *   27/08/07    0.1         created file
+ *   07/09/07    0.2         made changes to accomodate
+ *                           new api functions             Wang Qinling
+ *   21/05/08    0.3         update api function           Huang Shen
+ *********************************************************************************************/
+#ifndef __MP3_ENC_INTERFACE_H_
+#define __MP3_ENC_INTERFACE_H_
+
+#ifdef __cplusplus
+#define EXTERN extern "C"
+#else
+#define EXTERN
+#endif
+
+#define ENC_NUM_MEM_BLOCKS                6
+#define MP3E_INPUT_BUFFER_SIZE            1152
+/* Data type */
+typedef unsigned char     MP3E_UINT8;
+typedef char              MP3E_INT8;
+typedef unsigned short    MP3E_UINT16;
+typedef short             MP3E_INT16;
+typedef unsigned int      MP3E_UINT32;
+typedef int               MP3E_INT32;
+
+typedef enum
+{
+    MP3E_16_BIT_INTPUT,            /* 16-bit input format */
+}MP3E_INPUT_FORMAT;
+
+typedef enum
+{
+    MP3E_SUCCESS = 0,              /* Successful initialization */
+    MP3E_ERROR_INIT_BITRATE,       /* If the bitrate passed by the application to the init
+                                   routine is invalid */
+    MP3E_ERROR_INIT_SAMPLING_RATE, /* If the sampling rate passed by the application to the
+                                   init routine is invalid */
+    MP3E_ERROR_INIT_MODE,          /* If the stereo mode passed by the application to the init
+                                   routine is invalid */
+    MP3E_ERROR_INIT_FORMAT,        /* If the input format passed by the application to the init
+                                   routine is invalid */
+    MP3E_ERROR_INIT_QUALITY,       /* If the value of quality passed by the application to the init
+                                   routine is invalid */
+    MP3E_ERROR_INIT_QUERY_MEM      /* If the call to query_mem_mp3e() is unsuccessful */
+}MP3E_RET_VAL;
+
+typedef enum
+{
+    FAST_STATIC_MEMORY = 0,  /* Fast Static memory (state) */
+    SLOW_STATIC_MEMORY,      /* Slow Static memory (state) */
+    FAST_SCRATCH_MEMORY,     /* Fast Scratch memory */
+    SLOW_SCRATCH_MEMORY      /* Slow Scratch memory */
+}MP3E_MEM_DESC;
+
+typedef struct
+{
+    MP3E_INT32 app_sampling_rate;     /* sampling rate of the input file in Hz. The following
+                                      sampling rates are possible: 32000, 44100 and 48000.
+                                      This parameter needs to be filled by the
+                                      application.*/
+    MP3E_INT32 app_bit_rate;          /* bit rate for encoding, in kbps. The following bit
+                                      rates are possible: 32, 40, 48, 56, 64, 80, 96, 112,
+                                      128, 160, 192, 224, 256, 320 kbps. This parameter
+                                      needs to be filled by the application */
+    MP3E_INT32 app_mode;              /* mode for the encoder. The various modes are defined by
+                                      different bit fields of this 32-bit word.
+                                      This parameter needs to be filled by the application.
+                                      The following bits are used:
+                                      b1-b0: Stereo mode bits
+                                      Two values are currently possible:
+                                      00: stereo mode is joint stereo
+                                      01: stereo mode is mono
+                                      b9-b8: Input format bit
+                                      00: Input format is L/R interleaved
+                                      01: Input format is with contiguous L samples,
+                                      followed by contiguous R samples
+                                      b17-b16: Input quality bits
+                                      00: Low quality
+                                      01: High quality
+                                      Other bits are reserved. */
+    MP3E_INT32 mp3e_outbuf_size;      /* size of the required output buffer in bytes.
+                                      The MP3 encoder will fill this parameter and return.
+                                      The application has to allocate an output buffer of
+                                      this size or more. The maximum value that can be
+                                      returned by the MP3 encoder for this output buffer
+                                      size is 1440 bytes */
+}MP3E_Encoder_Parameter;
+
+typedef struct
+{
+    MP3E_MEM_DESC type;           /* Memory block type (Fast or Slow) */
+    MP3E_INT32 size;              /* Memory block size */
+    MP3E_INT32 align;             /* Memory block alignment in bytes */
+    MP3E_INT32 *ptr;              /* Memory block pointer */
+}MP3E_Mem_Alloc_Info;
+
+
+typedef struct
+{
+    MP3E_INT32 instance_id;
+    MP3E_Mem_Alloc_Info mem_info[ENC_NUM_MEM_BLOCKS];
+    MP3E_INT32 num_bytes;
+}MP3E_Encoder_Config;
+
+EXTERN MP3E_RET_VAL mp3e_query_mem (MP3E_Encoder_Config *enc_config);
+
+EXTERN MP3E_RET_VAL mp3e_encode_init (MP3E_Encoder_Parameter *params, MP3E_Encoder_Config *enc_config);
+
+EXTERN void mp3e_encode_frame (MP3E_INT16 *inbuf, MP3E_Encoder_Config *enc_config, MP3E_INT8 *outbuf);
+
+EXTERN void mp3e_flush_bitstream ( MP3E_Encoder_Config *enc_config,MP3E_INT8 *outbuf);
+
+EXTERN const char *MP3ECodecVersionInfo (void);
+
+#endif
--- /dev/null
+++ gst-fsl-plugins-3.0.7/inc/core_lib/peq_ppp_interface.h
@@ -0,0 +1,175 @@
+/*
+* Copyright (c) 2007-2010, 2012-2013, Freescale Semiconductor, Inc. 
+*/
+
+/*
+* This library is free software; you can redistribute it and/or
+* modify it under the terms of the GNU Lesser General Public
+* License as published by the Free Software Foundation; either
+* version 2.1 of the License, or (at your option) any later version.
+*
+* This library is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* Lesser General Public License for more details.
+*
+* You should have received a copy of the GNU Lesser General Public
+* License along with this library; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+ /****************************************************************************
+ * ANSI C source code
+ *
+ * Project Name : Parametric EQ PPP
+ * File Name    : peq_ppp_interface.h
+ *
+ ***************************************************************************/
+ /***************************************************************************
+ *   CHANGE HISTORY
+ *    dd/mm/yy        Code Ver      CR          Author     Description
+ *    --------        -------      -------      ------     -----------
+ *   17/09/2007       0.1     	  engr49841     Tao Jun    Created file
+ *   09/11/2007       0.2         engr55894     Tao Jun    Add _TCHAR definition
+ *   14/11/2007       0.3         engr56706     Tao Jun    Add attenuation definition
+ *   19/12/2007       0.4         engr59199     Tao Jun    Change PCMBLKSZ to 256
+ *   04/01/2008       0.5         engr61453     Tao Jun    Delete redundant definition
+ *   20/05/2008       0.6         engr76819     Tao Jun    Added version API
+ *   12/12/2008       0.7         engr102467    Tao Jun    Added zero phase API
+ *
+ **************************************************************************/
+#ifndef __PEQ_PPP_INTERFACE_H
+#define __PEQ_PPP_INTERFACE_H
+
+#include "ppp_interface.h"
+
+#ifdef __cplusplus
+#define EXTERN extern "C"
+#else
+#define EXTERN
+#endif
+
+#define PEQ_FAST_MEMORY                 1
+#define PEQ_SLOW_MEMORY                 2
+#define PEQ_MAX_NUM_MEM_REQS            1       /* presently we need seperate chunk of memory for scratch_lf */
+#define LONG_BOUNDARY                   4
+#define NPCMCHANS                       8       /*total channels*/
+#define BANDSINGRP			10
+/*#define PEQ_INPUT_BUFFER_SIZE           (PCMBUFSZ*NPCMCHANS)*/
+#define PEQ_TRUE			1
+#define PEQ_FALSE			0
+#define PEQ_MAX_SAMPLES                 1024
+
+/* Data type */
+#ifdef _WIN32
+typedef __int64 PEQ_I64;
+#else
+typedef long long PEQ_I64;
+#endif
+typedef unsigned char PEQ_U8;
+typedef char PEQ_I8;
+typedef unsigned short PEQ_U16;
+typedef short PEQ_I16;
+typedef unsigned int PEQ_U32;
+typedef int PEQ_I32;
+typedef PEQ_U32 PEQ_BOOL;
+typedef void PEQ_VOID;
+#define PEQ_FILE FILE
+#ifdef __WINCE
+#define  PEQ_TCHAR _TCHAR
+#endif
+/* Define NULL pointer value*/
+#ifndef NULL
+#ifdef  __cplusplus
+#define NULL    0
+#else
+#define NULL    ((PEQ_VOID *)0)
+#endif
+#endif
+#define	PEQ_NULL NULL
+
+/**** PEQ structure declarations ****/
+typedef struct {
+	PEQ_I32 Fc;
+	PEQ_I32 Gain;
+	PEQ_I32 Q_value;
+	PEQ_I32 FilterType;
+						/*****
+						FilterType = 0 : peak filter
+						FilterType = 1 : low shelving filter
+						FilterType = 2 : Hi- shelving filter
+						FilterType = 3 : lowpass crossover filter
+						FilterType = 4 : Hignpass crossover filter
+						******/
+	} FILTER_PARA;
+
+typedef struct {
+	/* PPP common data */
+	PPP_INPUTPARA ppp_inputpara;
+	/* PEQ private data */
+	PEQ_I32 channelnumber;			/* total channel number */
+	PEQ_I32 peqenablemask;			/* channel mask */
+	PEQ_I32 chennelfilterselect;		/* channel filter Selection */
+	PEQ_I32 premode;			/* predetermined mode bit */
+	PEQ_I32 calbandsperfrm;			/* calculate bands number per frame */
+	PEQ_I32 bandspergroup[BANDSINGRP];	/* every groups bands number,default value is 4*/
+        FILTER_PARA group_band[NPCMCHANS][BANDSINGRP];
+						/* group m band n input parameters*/
+	PEQ_I32 attenuation;			/* attenuation factor in dB*/
+        PEQ_BOOL zerophaseflag;                  /* zero phase flag */
+        } PEQ_PL;
+
+typedef struct{
+	PPP_INFO ppp_info;
+	PEQ_I32 volumeregi[NPCMCHANS];		/* volume output register*/
+	PEQ_I32 chennelfilterselect;		/* channel filter Selection*/
+	PEQ_I32 bandspergroup[BANDSINGRP];	/* every groups bands number,default value is 4*/
+        FILTER_PARA group_band[NPCMCHANS][BANDSINGRP];
+						/* group m band n input parameters*/
+	PEQ_I32 attenuation;			/* attenuation factor in dB*/
+	} PEQ_INFO;
+
+/* Error types */
+typedef enum {
+        PEQ_OK = 0,                             /* Success,no error */
+        PEQ_END_OF_STREAM,                      /* end of bit stream */
+        PEQ_ERROR_INIT = 51,                    /* initialization error */
+        PEQ_ERROR_INVALID_PARAM = 52            /* invalid Parameters to decode frame */
+        /*any other errors need to add*/
+        } PEQ_RET_TYPE;
+
+typedef enum{
+        PEQ_STATIC_MEM,                         /* 0 for static memory */
+        PEQ_SCRATCH_MEM                         /* 1 for scratch memory */
+        } PEQ_MEM_DESC;
+
+/*chunks memory configuration parameters*/
+typedef struct {
+        PEQ_I32 peq_size;                       /* Size in bytes */
+        PEQ_I32 peq_type;                       /* Memory type Fast or Slow */
+        PEQ_MEM_DESC peq_mem_desc;              /* to indicate if it is scratch memory */
+        PEQ_I32 peq_priority;                   /* In case of fast memory, specify the priority */
+        void *app_base_ptr;                     /* Pointer to the base memory , which will be allocated and
+                                                filled by the  application */
+        } PEQ_Mem_Alloc_Info_Sub;
+
+/*Memory information structure array*/
+typedef struct {
+        PEQ_I32 peq_num_reqs;
+        PEQ_Mem_Alloc_Info_Sub mem_info_sub [PEQ_MAX_NUM_MEM_REQS];
+        } PEQ_Mem_Alloc_Info;
+
+/* PPP parameter  structure */
+struct PEQ_Dec_Config;
+typedef struct PEQ_Dec_Config{
+        PEQ_Mem_Alloc_Info peq_mem_info;
+        void *peq_decode_info_struct_ptr;	/*point to Global_struct*/
+        int WM;
+        } PEQ_PPP_Config;
+
+
+EXTERN PEQ_RET_TYPE peq_query_ppp_mem(PEQ_PPP_Config *dec_config);
+EXTERN PEQ_RET_TYPE peq_ppp_init(PEQ_PPP_Config *dec_config);
+EXTERN PEQ_RET_TYPE peq_ppp_frame(PEQ_PPP_Config *dec_config,PEQ_PL *peq_list_ptr,PEQ_INFO *peq_info_ptr);
+EXTERN const char *PEQPPPVersionInfo(void);
+#endif
--- /dev/null
+++ gst-fsl-plugins-3.0.7/inc/core_lib/parser/fsl_media_types.h
@@ -0,0 +1,275 @@
+/*
+* Copyright (c) 2011-2012, Freescale Semiconductor, Inc. 
+ */
+
+/*
+* This library is free software; you can redistribute it and/or
+* modify it under the terms of the GNU Lesser General Public
+* License as published by the Free Software Foundation; either
+* version 2.1 of the License, or (at your option) any later version.
+*
+* This library is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* Lesser General Public License for more details.
+*
+* You should have received a copy of the GNU Lesser General Public
+* License along with this library; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+/*
+*  History :
+*  Date             Author              Version    Description
+*
+*  Oct,2009         Amanda              1.0        Initial Version
+*
+*/
+
+#ifndef _FSL_MMLAYER_MEDIA_TYPES_H
+#define _FSL_MMLAYER_MEDIA_TYPES_H
+
+
+/*
+ * Media types of a track. 
+ */
+typedef enum
+{    
+    MEDIA_TYPE_UNKNOWN = 0,
+    MEDIA_VIDEO,
+    MEDIA_AUDIO,
+    MEDIA_TEXT, /* subtitle text or stand-alone application, string-based or bitmap-based */
+    MEDIA_MIDI    
+}MediaType;
+
+
+#define UNKNOWN_CODEC_TYPE 0
+#define UNKNOWN_CODEC_SUBTYPE 0 /*  Value 0 is reserved for unknown subtypes or no subtypes. */
+
+/*
+ * Video codec types. 
+ */
+typedef enum
+{    
+    VIDEO_TYPE_UNKNOWN = 0,
+    VIDEO_UNCOMPRESSED, /* uncompressed video, every frame is a key frame */
+    VIDEO_MPEG2, /* MPEG-2 video, ISO/IEC 13818-2 */
+    VIDEO_MPEG4, /* MPEG-4 video, ISO/IEC 14496-2 */
+    VIDEO_MS_MPEG4, /* Microsoft MPEG-4 video*/   
+    VIDEO_H263, /* ITU-T H.263 */
+    VIDEO_H264, /* H.264, ISO/IEC 14496-10 */
+    VIDEO_MJPG, /* Motion-JPEG (M-JPEG) is a variant of the ISO JPEG specification 
+                for use with digital video streams.
+                Instead of compressing an entire image into a single bitstream, 
+                Motion-JPEG compresses each video field separately, returning 
+                the resulting JPEG bitstreams consecutively in a single frame.*/
+    VIDEO_DIVX, /* DivX video types*/
+    VIDEO_XVID,
+    VIDEO_WMV,    
+    VIDEO_SORENSON_H263, /* Sorenson Spark. Deprecated value. 
+                            Please use type "VIDEO_SORENSON" and subtype "VIDEO_SORENSON_SPARK.*/
+    VIDEO_FLV_SCREEN, /* Screen videos, by Adobe */    
+    VIDEO_ON2_VP, /* True Motion video types by On2 */
+    VIDEO_REAL, /* Real video types */
+    VIDEO_JPEG, /* ISO JPEG still image */
+    VIDEO_SORENSON /* Sorenson video types, including Sorenson Spark, SVQ1, SVQ3 etc */ 
+}VideoCodecType;
+
+
+/*
+ * Audio codec types. 
+ */
+typedef enum
+{    
+    AUDIO_TYPE_UNKNOWN = 0,
+    AUDIO_PCM, /* Linear PCM, little-endian or big-endian */
+    AUDIO_PCM_ALAW,
+    AUDIO_PCM_MULAW,
+    AUDIO_ADPCM,
+    AUDIO_MP3,  /* MPEG-1/2 Layer 1,2,3 */  
+    AUDIO_AAC,   /* MPEG-4 AAC, 14496-3 */
+    AUDIO_MPEG2_AAC, /* MPEG-2 AAC, 13818-7 */
+    AUDIO_AC3,
+    AUDIO_WMA,    
+    AUDIO_AMR,  /* Adaptive Multi-Rate audio */  
+    AUDIO_DTS,
+    AUDIO_VORBIS,
+    AUDIO_FLAC,
+    AUDIO_NELLYMOSER,
+    AUIDO_SPEEX,
+    AUDIO_REAL /* Real audio types */
+    
+}AudioCodecType;
+
+
+/*
+ * text types. 
+ */
+typedef enum
+{    
+    TXT_TYPE_UNKNOWN = 0,
+    TXT_3GP_STREAMING_TEXT, /* 3GP streaming text, timed code, string-based */
+    TXT_DIVX_FEATURE_SUBTITLE, /* DivX feature subtitle, bitmap-based */
+    TXT_DIVX_MENU_SUBTITLE, /* DivX menu subtitle, bitmap-based */
+    
+    //TXT_QT_TIMECODE,      /* Quicktime timed code */
+    TXT_QT_TEXT,            /* Quicktime text */
+    TXT_SUBTITLE_SSA,       /* SubStation Alpha */
+    TXT_SUBTITLE_ASS,       /* Advanced SubStation Alpha */
+    TXT_SUBTITLE_TEXT                 
+}TextType;
+
+
+/*******************************************************************************
+ *  Video Subtypes.
+ *******************************************************************************/
+typedef enum
+{
+    VIDEO_DIVX3 = 1,    /* version 3*/
+    VIDEO_DIVX4,    /* version 4*/
+    VIDEO_DIVX5_6 /* version 5 & 6*/
+    
+}DivXVideoTypes; /* DivX video types */
+
+typedef enum
+{
+    VIDEO_MS_MPEG4_V2 = 1, /* Microsoft MPEG-4 video version 2, fourcc 'mp42'*/
+    VIDEO_MS_MPEG4_V3 /* Microsoft MPEG-4 video version 3, fourcc 'mp43' */
+    
+}MsMPEG4VideoTypes; /* Microsoft MPEG-4 video types */
+
+
+typedef enum
+{
+    MPEG4_VIDEO_AS_PROFILE  = 1 /* Fourcc 'RMP4', MPEG-4 AS profile */
+    
+}MPEG4VideoTypes; /* Microsoft MPEG-4 video types */
+
+
+typedef enum
+{
+    VIDEO_WMV7 = 1,
+    VIDEO_WMV8,
+    VIDEO_WMV9,
+    VIDEO_WMV9A,    /* Windows Media Video 9 Advanced Profile. The codec originally submitted for consideration as SMPTE VC1. 
+                    This is not VC1 compliant and is no longer supported by Microsoft */
+                    
+    VIDEO_WVC1      /* Microsoft's implementation of the SMPTE VC1 codec */
+    
+}WMVVideoTypes; /* WMV video types */
+
+
+typedef enum
+{
+    FLV_SCREEN_VIDEO = 1, /* Screen video version 1*/
+    FLV_SCREEN_VIDEO_2  /* Screen video version 2 */
+    
+}ScreenVideoTypes;  /* Screen video types by Adobe*/
+
+
+typedef enum
+{
+    VIDEO_VP6 = 1,
+    VIDEO_VP6A,
+    VIDEO_VP7,
+    VIDEO_VP8
+}On2VideoTypes; /* On2 video types */
+
+
+typedef enum
+{
+    REAL_VIDEO_RV10 = 1,
+    REAL_VIDEO_RV20,   
+    REAL_VIDEO_RV30,
+    REAL_VIDEO_RV40
+}RealVideoTypes;
+
+/*
+There are two flavors of Motion-JPEG currently in use. These two formats differ 
+based on their use of markers.
+Motion-JPEG format A supportsmarkers;Motion-JPEG format B does not.
+Each field of Motion-JPEG format A fully complies with the ISO JPEG specification, 
+and therefore supports application markers.*/
+typedef enum
+{
+    VIDEO_MJPEG_FORMAT_A = 1, /* Motion-JPEG(format A), support markers */
+    VIDEO_MJPEG_FORMAT_B,      /* Motion-JPEG(format B), not support markers */
+    VIDEO_MJPEG_2000
+
+}MotionJPEGVideoTypes;
+
+
+
+typedef enum
+{
+    VIDEO_SORENSON_SPARK = 1, /* Sorenson H.263, almost H.263 but not standard */
+    VIDEO_SVQ1, /* Sorenson Video 1, a custom beast */
+    VIDEO_SVQ3  /* Sorenson Video 3, SVQ3 is quite similar to H.264, not H.263 */
+    
+}SorensonVideoTypes;
+
+
+/*******************************************************************************
+ *  Audio Subtypes
+ *******************************************************************************/
+
+typedef enum
+{
+    REAL_AUDIO_SIPR = 1,
+    REAL_AUDIO_COOK,    
+    REAL_AUDIO_ATRC,
+    REAL_AUDIO_RAAC,
+}RealAudioTypes;
+
+typedef enum
+{
+    AUDIO_WMA1 = 1,
+    AUDIO_WMA2,
+    AUDIO_WMA3
+    
+}WMAAudioTypes; 
+
+typedef enum
+{
+    AUDIO_AMR_NB = 1, /* Adaptive Multi-Rate - narrow band */
+    AUDIO_AMR_WB, /* Adaptive Multi-Rate - Wideband */
+    AUDIO_AMR_WB_PLUS   /* Extended Adaptive Multi-Rate - Wideband */
+    
+}AmrAudioTypes;
+
+
+typedef enum
+{  
+    AUDIO_PCM_U8 = 1,   /* PCM, unsigned, 8 pits per sample */
+    AUDIO_PCM_S16LE,    /* PCM, signed little-endian, 16 bits per sample */
+    AUDIO_PCM_S24LE,    /* PCM, signed little-endian, 24 bits per sample */
+    AUDIO_PCM_S32LE,    /* PCM, signed little-endian, 32 bits per sample */
+
+    AUDIO_PCM_S16BE,    /* PCM, signed big-endian, 16 bits per sample */
+    AUDIO_PCM_S24BE,    /* PCM, signed big-endian, 24 bits per sample */
+    AUDIO_PCM_S32BE,     /* PCM, signed big-endian, 32 bits per sample */
+
+    AUDIO_PCM_DVD,    /* PCM, dvd, 24 bits per sample */
+    AUDIO_PCM_S8
+}PCMAudioTypes;
+
+
+typedef enum
+{
+    AUDIO_IMA_ADPCM = 1,  /* IMA 4:1 */
+    AUDIO_ADPCM_MS = 2  /* Microsoft ADPCM audio */
+
+}ADPCMAudioTypes;
+
+typedef enum
+{
+    AUDIO_ER_BSAC = 1, /* In fact we only care about whether it's BSAC or not */
+    AUDIO_AAC_RAW = 2, /* ADTS without sync word, such as in mp4 container */
+    AUDIO_AAC_ADTS = 3,
+    AUDIO_AAC_ADIF = 4
+}AACAudioTypes;
+
+
+
+#endif /* _FSL_MMLAYER_MEDIA_TYPES_H */
+
--- /dev/null
+++ gst-fsl-plugins-3.0.7/inc/core_lib/parser/fsl_parser.h
@@ -0,0 +1,845 @@
+/*
+* Copyright (c) 2011-2012, Freescale Semiconductor, Inc. 
+ */
+
+/*
+* This library is free software; you can redistribute it and/or
+* modify it under the terms of the GNU Lesser General Public
+* License as published by the Free Software Foundation; either
+* version 2.1 of the License, or (at your option) any later version.
+*
+* This library is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* Lesser General Public License for more details.
+*
+* You should have received a copy of the GNU Lesser General Public
+* License along with this library; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+/*
+ *
+ *  History :
+ *  Date             Author              Version    Description
+ *
+ *  Oct, 2009        Amanda              1.0        Initial Version
+ *  Jan, 2010        Amanda              1.1        Extend user data ID.
+ *  Apr, 2010        Amanda              2.0        Further unify API, add entry point "FslParserInit" for DLL loading.
+ *  Mar, 2010        Larry               2.1        Add API for getting Meta data
+ *  Sep, 2011        Fanghui             2.2        Add USER_DATA_TRACKNUMBER, USER_DATA_TOTALTRACKNUMBER
+ *  May, 2012        Fanghui             2.3		Change FslParserGetProgramTracks definition
+ *  May, 2012        Fanghui             2.4		Add USER_DATA_LOCATION
+ *  Jun, 2012        Fanghui             2.5		Add USER_DATA_PROGRAMINFO
+ *  Sep, 2012        Fanghui             2.6		Add USER_DATA_PMT
+ */
+
+#ifndef _FSL_PARSER_COMMON_H
+#define _FSL_PARSER_COMMON_H
+
+#include "fsl_media_types.h"
+#include "fsl_types.h"
+
+#ifdef __cplusplus
+#define EXTERN extern "C"
+#else
+#define EXTERN
+#endif
+
+
+/* Warning:
+ * It's not recommended to use any enum types as API arguments or return value!
+ * Please use data types that can explicitly tell the data length and asign them the listed enum values.
+ * It's because different compilers can treat enum as different types such as integer or unsinged char.
+ * If the parser library and plug-in(filter) are built by different compliers, the data length mismatch
+ * will cause error.
+ */
+
+
+#ifdef __WINCE
+	#define DEBUGMSG
+    //#define PARSERMSG(cond, fmt, ...) DEBUGMSG(cond, _T(fmt), __VA_ARGS__))
+    //#define PARSERMSG(fmt, ...) DEBUGMSG(1, (_T(fmt),  __VA_ARGS__))
+    #define PARSERMSG(fmt, ...)
+#elif WIN32
+	#define DEBUGMSG(cond, fmt) printf fmt
+	#define PARSERMSG(fmt, ...) printf(fmt, __VA_ARGS__)
+#else /* linux platform */
+    #ifdef DEBUG
+        #define PARSERMSG printf
+    #else
+        #define PARSERMSG(fmt...)
+    #endif
+#endif
+
+
+typedef void * FslParserHandle;
+
+#define PARSER_INVALID_TRACK_NUMBER   (-1)
+
+#define PARSER_UNKNOWN_DURATION 0    /* Unknown movie, track or sample duration.
+                                       In some broadcasting sources (eg. MMS of broadcasting)
+                                       or recording clips, the movie or track's duration is set to 0.
+                                       It means the duration is unknown, not an empty clip or track.
+                                       The plug-in and the core parser shall just try to read as many sample as possible until EOF.*/
+
+#define PARSER_UNKNOWN_TIME_STAMP (-1) /* The time stamp is unknown. Usually used when the exact audio samples
+                                        are not known until after decoding. And so only audio decoder can give
+                                        a valid time stamp for each decoded audio frame.
+                                        However, for the 1st sample after seeking,
+                                        the parser MUST NOT use this value but shall give a valid time stamp.*/
+
+#define PARSER_UNKNOWN_BITRATE  0    /* unknown bitrate */
+
+
+/*
+ * Common error codes of parsers,
+ * within the range [-100 , +100].
+ * Different parsers can extend the format specific errors OUTSIDE this range,
+ * in their own API header files.
+ */
+
+enum
+{
+    PARSER_SUCCESS  = 0,
+    PARSER_EOS = 1,    /* reach the end of the track/movie */
+    PARSER_BOS = 2,    /* reach the beginning of the track/movie */
+    PARSER_NEED_MORE_DATA = 3,  /* No longer used. Shall use "PARSER_INSUFFICIENT_DATA" */
+
+    /* errors */
+    PARSER_ERR_UNKNOWN = -1, /* Unknown error, not captured by parser logic */
+
+    PARSER_ERR_INVALID_API = -2, /* Some common API is not implemented properly */
+
+    PARSER_NOT_IMPLEMENTED = -5, /* No support for some feature. */
+    PARSER_ERR_INVALID_PARAMETER = -6, /* parameters are invalid */
+
+    PARSER_INSUFFICIENT_MEMORY = -7, /* memory not enough, causing general memory allocation failure */
+    PARSER_INSUFFICIENT_DATA = -8, /* data not enough, parser need more data to go ahead */
+
+    PARSER_ERR_NO_OUTPUT_BUFFER = -9, /* can not get sample buffer for output */
+
+    PARSER_FILE_OPEN_ERROR = -10,
+    PARSER_READ_ERROR = -11, /* file read error, no need for further error concealment */
+    PARSER_WRITE_ERROR = -12,
+    PARSER_SEEK_ERROR = -13, /* file system seeking error */
+    PARSER_ILLEAGAL_FILE_SIZE = -14, /* file size is wrong or exceeds parser's capacity.
+                                       (some parser can not handle file larger than 2GB)*/
+    PARSER_ILLEAGAL_OPERATION =-15, /* the parser is being used improperly */
+
+    PARSER_ERR_INVALID_MEDIA = -20, /* invalid or unsupported media format */
+
+    PARSER_ERR_NOT_SEEKABLE = -21, /* This file is not seekable and does not support trick mode */
+
+    /* error concealment */
+    PARSER_ERR_CONCEAL_FAIL = -22, /* Error in bitstream and no sample can be found by error concealment.
+                                If the file is seekable, it's better to perform a seeking than further
+                                searching the bit stream for the next sample. */
+
+    PARSER_ERR_MEMORY_ACCESS_VIOLATION = -25, /* internal memory access error */
+
+    PARSER_ERR_TRACK_DISABLED = -30, /* The track is disabled and no media samples can be read from it. Only enabled track can output samples.*/
+    PARSER_ERR_INVALID_READ_MODE = -32, /* The reading mode is invalid, or some operation is illegal under current reading mode */
+
+
+};
+
+
+/*********************************************************************
+ * Reading mode. There are two options:
+ * a. File-based sample reading.
+ *      The reading order is same as that of track interleaving in the file.
+ *      Mainly for streaming application.
+ *
+ * b. Track-based sample reading.
+ *      Each track can be read independently from each other.
+ *
+ * Note:
+ * A parser may support only one reading mode. Setting it to a not-supported mode will fail.
+ * And it usually has a default reading mode.
+ ********************************************************************/
+enum
+{
+    PARSER_READ_MODE_FILE_BASED = 0, /* File-based sample reading.*/
+    PARSER_READ_MODE_TRACK_BASED /* Track-based sample reading.*/
+};
+
+
+
+
+/*********************************************************************
+ * sample flags :
+ * 32-bit long, properties of a sample read.
+ * The low 16 bits is reserved for common flag.
+ * Parsers can use high 16 bits to define their own flags.
+ ********************************************************************/
+#define FLAG_SYNC_SAMPLE 0X01  /* This is a sync sample */
+
+#define FLAG_SAMPLE_ERR_CONCEALED 0X02 /* This sample is got by error concealment, such as searching the bitstream.*/
+
+#define FLAG_SAMPLE_SUGGEST_SEEK 0X04   /* A seeking is suggested. Although sample is got by error concealment,
+                                        A/V sync may be impacted.
+                                        If the file is seekable, a seeking on all tracks can save the A/V sync.*/
+#define FLAG_SAMPLE_NOT_FINISHED 0X08   /* Sample is NOT finished at this call, large samples can be output in several calls. */
+
+#define FLAG_UNCOMPRESSED_SAMPLE 0X10 /* This is a uncompressed sample.
+                                        Warning:
+                                        A track may have both compressed & uncompressed samples.
+                                        But some AVI clips seem to abuse this flag, sync samples are mark as uncompressed,
+                                        although they are actually compressed ones.
+                                        Now suggest not care this flag.*/
+
+#define FLAG_SAMPLE_NEWSEG       0x20 /* A new segment of new sample */
+
+/*********************************************************************
+ * seeking flags :
+ when to seek, must set one of the following flags
+ ********************************************************************/
+#define SEEK_FLAG_NEAREST 0X01  /* Default flag. The actual seeked time shall be nearest one to the given time (can be later or earlier)*/
+#define SEEK_FLAG_NO_LATER  0X02    /* The actual seeked time shall be no later than the given time */
+#define SEEK_FLAG_NO_EARLIER 0X03    /* The actual seeked time shall be no earlier than the given time */
+#define SEEK_FLAG_FUZZ 0X04 /* Reserved. No accurate request on time but request quick response.
+                               Parsers shall optimize performances with other flags.*/
+
+
+/*********************************************************************
+ * direction for trick mode/sync sample reading
+ ********************************************************************/
+#define FLAG_BACKWARD   0X00
+#define FLAG_FORWARD    0x01
+
+
+/*********************************************************************
+ * User data ID
+ * Some File level metadata
+*********************************************************************/
+typedef enum FSL_PARSER_USER_DATA_TYPE
+{
+    USER_DATA_TITLE = 0,      /* title of the content */
+    USER_DATA_LANGUAGE,       /* user data may tell the language of the movie as a string */
+    USER_DATA_GENRE,          /* genre of the content, mainly music */
+    USER_DATA_ARTIST,         /* main artist and performer */
+    USER_DATA_COPYRIGHT,      /* copyright statement */
+    USER_DATA_COMMENTS,       /* comments of the content */
+    USER_DATA_CREATION_DATE,  /* date the movie content was created */
+    USER_DATA_RATING,         /* ? */
+    USER_DATA_ALBUM,          /* album name of music content */
+    USER_DATA_VCODECNAME,     /* video codec name */
+    USER_DATA_ACODECNAME,     /* audio codec name */
+    USER_DATA_ARTWORK,        /* artwork of movie or music */
+    USER_DATA_COMPOSER,       /* name of composer */
+    USER_DATA_DIRECTOR,       /* name of movie's director */
+    USER_DATA_INFORMATION,    /* information about the movie */
+    USER_DATA_CREATOR,        /* name of the file creator or maker */
+    USER_DATA_PRODUCER,       /* name of producer */
+    USER_DATA_PERFORMER,      /* name of performer */
+    USER_DATA_REQUIREMENTS,   /* special hardware and software requirements */
+    USER_DATA_SONGWRITER,     /* name of songwriter */
+    USER_DATA_MOVIEWRITER,    /* name of movie's writer */
+    USER_DATA_TOOL,           /* writing application */
+    USER_DATA_DESCRIPTION,    /* movie description */
+    USER_DATA_TRACKNUMBER,    /* track number */
+    USER_DATA_TOTALTRACKNUMBER,    /* total track number */
+    USER_DATA_LOCATION,       /* geographic location */  
+
+    /* add more? */
+    USER_DATA_CHAPTER_MENU,     /* Chapter Menu information */
+    USER_DATA_FORMATVERSION,   /* container format version */
+    USER_DATA_PROFILENAME,     /* Profile Name (DivX)*/
+
+    USER_DATA_PROGRAMINFO,     /* program info for ts */
+    USER_DATA_PMT,             /* program map table */
+
+    USER_DATA_AUD_ENC_DELAY,   /* audio encoding delay */
+    USER_DATA_AUD_ENC_PADDING, /* audio encoding padding */
+
+    USER_DATA_MAX
+} UserDataID;
+
+/*********************************************************************
+ * User data format
+*********************************************************************/
+typedef enum FSL_PARSER_USER_DATA_FORMAT
+{
+    USER_DATA_FORMAT_UTF8,         /* all strings in stream should be convert to UTF-8 and output */
+
+    USER_DATA_FORMAT_INT_BE,
+    USER_DATA_FORMAT_UINT_BE,
+    USER_DATA_FORMAT_FLOAT32_BE,
+    USER_DATA_FORMAT_FLOAT64_BE,
+
+    USER_DATA_FORMAT_JPEG,
+    USER_DATA_FORMAT_PNG,
+    USER_DATA_FORMAT_BMP,
+    USER_DATA_FORMAT_GIF,
+
+    USER_DATA_FORMAT_CHAPTER_MENU,
+    /* add more? */
+
+    USER_DATA_FORMAT_PROGRAM_INFO,
+    USER_DATA_FORMAT_PMT_INFO,
+
+    USER_DATA_FORMAT_INT_LE,
+    USER_DATA_FORMAT_UINT_LE,
+
+    USER_DATA_FORMAT_MAX
+} UserDataFormat;
+
+
+/*********************************************************************
+ * file I/O interface on a file or live source.
+
+open
+    Open a local file or URL.
+    Arguments:
+        fileName [in] File name or url to open.
+                      To open the movie source file, just set file name to NULL.
+                      To open another external file for some track (eg. MP4), set the url.
+
+        mode [in] Open mode, same as libc. Such as "rb".
+
+    Return value:
+        Handle of the opened file. NULL for failure.
+
+read
+    Read data from the file.
+    Arguments:
+        handle [in] Handle of the file.
+        buffer [in] Pointer to a block of memory, to receive the data.
+        size[in] Data size to read, in bytes.
+
+    Return value:
+        The total number of bytes successfully read.
+        If this number differs from the size parameter, either an error occurred or the EOF was reached.
+
+
+seek
+    Seek the stream.
+    Arguments:
+        handle [in] Handle of the file.
+        offset [in] The offset.
+                    To move to a position before the end-of-file, you need to pass a negative value in offset and set whence to SEEK_END.
+
+        whence in]  The new position, measured in bytes from the beginning of the file,
+                    is obtained by adding offset to the position specified by whence.
+                    SEEK_SET - Set position equal to offset bytes.
+                    SEEK_CUR - Set position to current location plus offset .
+                    SEEK_END - Set position to end-of-file plus offset.
+    Return value:
+        Upon success, returns 0; otherwise, returns -1.
+
+tell
+    Tell the position of the file pointer
+    Arguments:
+        handle [in] Handle of the file.
+
+    Return value:
+        Returns the position of the file pointer in bytes; i.e., its offset into the file stream.
+        If error occurs or this feature can not be supported (eg. broadcast application), returns -1.
+
+size
+    Tell the size of the entire file.
+    Arguments:
+        handle [in] Handle of the file.
+    Return value:
+        Returns the file size in bytes.
+        If error occurs or this feature can not be supported (eg. broadcast application), returns -1.
+
+check_available_bytes
+    Tell the availble bytes of the file. Especially useful for a live source file (streaming).
+    The parser can decide not to read if cached data is not enough and so avoid reading failure in unexpected context.
+    For a local file, any bytes request from the parser can be met as long as it's within the file range.
+
+    Arguments:
+        handle [in] Handle of the file.
+        bytes_requested [in]    Bytes requested for further parsing. This information can help the application
+                                to cache enough data before calling parser API next time.
+                                If the parser can not know the exact data size needed, set it to 0.
+
+    Return value:
+        If the file source can always meet the data reading request unless EOF (eg. a local file or a pull-mode live source),
+        returns the data size from the current file pointer to the file end.
+
+        Otherwise (eg. a push-mode live source), returns the cached data size.
+        If error occurs or this feature can not be supported (eg. broadcast application), returns -1.
+
+close
+    Close the file.
+    Arguments:
+        handle [in] Handle of the file.
+
+    Return value:
+        Upon success, returns 0; otherwise, returns -1.
+*/
+
+typedef void * FslFileHandle;
+
+/* Seek origin, position from where offset is added, same as libc */
+#ifndef FSL_SEEK_SET
+#define FSL_SEEK_SET 0 /* SEEK_SET, Beginning of file */
+#endif
+#ifndef FSL_SEEK_CUR
+#define FSL_SEEK_CUR 1  /* SEEK_CUR, Current position of file pointer */
+#endif
+#ifndef FSL_SEEK_END
+#define FSL_SEEK_END 2  /* SEEK_END, End of file */
+#endif
+
+typedef struct _FslFileStream
+{
+    FslFileHandle (*Open)(const uint8 * fileName, const uint8 * mode, void * context); /* Open a file or URL */
+    int32 	(*Close)(FslFileHandle handle, void * context); /* Close the stream */
+    uint32  (*Read)(FslFileHandle handle, void * buffer, uint32 size, void * context); /* Read data from the stream */
+    int32 	(*Seek)(FslFileHandle handle, int64 offset, int32 whence, void * context);  /* Seek the stream */
+    int64  	(*Tell)(FslFileHandle handle, void * context); /* Tell the current position from start of the stream */
+    int64 	(*Size)(FslFileHandle handle, void * context); /* Get the size of the entire stream */
+    int64   (*CheckAvailableBytes)(FslFileHandle handle, int64 bytesRequested, void * context); /* How many bytes cached but not read yet */
+
+    void * reserved[2];
+
+} FslFileStream;
+
+
+/*********************************************************************
+ * Core parser memory callback function pointer table.
+ *********************************************************************/
+typedef struct
+{
+    void* (*Calloc) (uint32 numElements, uint32 size);
+    void* (*Malloc) (uint32 size);
+    void  (*Free) (void * ptr);
+    void* (*ReAlloc)(void * ptr, uint32 size); /* necessary for index scanning!*/
+
+}ParserMemoryOps; /* callback operation callback table */
+
+
+/********************************************************************************************************
+Callback functions to request/release an output buffer.
+Usually, the core parser requests an output buffer, fill the media data and return it to the application
+on GetNextSample(). But, on flushing (eg. on seek or deletion), the core parser need explicitly release
+all buffers not returned yet.
+
+RequestBuffer
+    Request an output buffer.
+
+    Arguments:
+        streamNum [in] Track number, 0-based.
+
+        size [in,out] The requested buffer size as input, and the size actually got as output, both in bytes.
+                      The actually got size can be larger than the requested size, and the parser can
+                      make full use of the buffer.
+
+        bufContext [out] A buffer context from the application. The parser shall not modify it.
+
+        parserContext [in] The parser context from the application, got on parser creation.
+
+    Return value:
+        Buffer pointer. NULL for failure.
+
+
+ReleaseBuffer
+    Release an output buffer explicitly.
+
+    Arguments:
+        streamNum [in] Track number, 0-based.
+        pBuffer [in] Buffer to release.
+        bufContext [in] The buffer context from the application, got on requestBuffer().
+        parserContext [in] The parser context from the application, got on parser creation.
+
+    Return value: none.
+
+********************************************************************************************************/
+
+typedef struct
+{
+    uint8* (*RequestBuffer) (uint32 streamNum, uint32 *size, void ** bufContext, void * parserContext);
+    void (*ReleaseBuffer) (uint32 streamNum, uint8 * pBuffer, void * bufContext, void * parserContext);
+
+}ParserOutputBufferOps;
+
+typedef struct _ChapterInfo
+{
+    uint32 ChapterUID;      /* UID for chapter */
+    uint32 dwStartTime;     /* Chapter's Start time in ms unit */
+    uint32 dwStopTime;      /* Chapter's Stop time in ms unit */
+    uint32 dwTitleSize;     /* Chapter Title size in byte */
+    char * Title;           /* The string for Title */
+}ChapterInfo;
+
+typedef struct _strChapterMenu
+{
+    uint32 EditionUID;      /* UID for Movie/Edition */
+    uint32 EdtionFlags;     /* Flags for Movie/Edition */
+    uint32 dwChapterNum;    /* Total number of chapters in this Edition */
+    ChapterInfo * pChapterList; /* the pointer to Chapter information list */
+}ChapterMenu;
+
+typedef struct _ProgramInfo
+{
+    uint32 m_dwChannel; //program_number in spec, for a broadcast channel.
+    uint32 m_dwPID; //program PID(packet ID)
+}ProgramInfo;
+
+typedef struct _ProgramInfoMenu
+{
+    uint32 m_dwProgramNum;
+    ProgramInfo m_atProgramInfo[0];
+}ProgramInfoMenu;
+
+
+#define INVALID_PID         (uint32)(-1)
+#define INVALID_CHANNEL     (uint32)(-1)
+
+
+typedef struct _TrackInfo
+{
+    uint32 m_dwTrackNo; //global track No
+    uint32 m_dwPID;     //PID(packet ID)
+    uint8 m_byLan[3];   //language
+    uint32 m_dwReserved[16];    
+}TrackInfo;
+
+//single program map table
+typedef struct _PMTInfo
+{
+    uint32 m_dwChannel; //program_number in spec, for a broadcast channel.
+    uint32 m_dwPID;     //PID(packet ID)
+    uint32 m_dwReserved[8];
+    uint32 m_dwTrackNum;    
+    TrackInfo *m_ptTrackInfo;
+}PMTInfo;
+
+//total program map table
+typedef struct _PMTInfoList
+{
+    uint32 m_dwProgramNum;
+    PMTInfo *m_ptPMTInfo;
+}PMTInfoList;
+
+/*********************************************************************************************************
+ *                  API Function Prototypes List
+ *
+ * There are mandatory and optional APIs.
+ * A core parser must implement the mandatory APIs while need not implement the optional one.
+ * And in its DLL entry point "FslParserInit", it shall set the not-implemented function pointers to NULL.
+ *
+ *********************************************************************************************************/
+
+/***************************************************************************************
+ *
+ *                Creation & Deletion
+ *
+ ***************************************************************************************/
+/* mandatory */
+typedef const char * (*FslParserVersionInfo)();
+
+typedef int32  (*FslCreateParser)(  bool isLive,
+                                    FslFileStream * streamOps,
+                                    ParserMemoryOps * memOps,
+                                    ParserOutputBufferOps * outputBufferOps,
+                                    void * context,
+                                    FslParserHandle * parserHandle);
+
+typedef int32 (*FslDeleteParser)(FslParserHandle parserHandle);
+
+
+/***************************************************************************************
+ *
+ *                 Index Table Loading, Export & Import
+ *
+ ***************************************************************************************/
+/* optional */
+typedef int32 (*FslParserInitializeIndex)(FslParserHandle parserHandle); /*Loading index from the movie file */
+
+typedef int32 (*FslParserImportIndex)(  FslParserHandle parserHandle, /* Import index from outside */
+                                        uint8 * buffer,
+                                        uint32 size);
+
+typedef int32 (*FslParserExportIndex)(  FslParserHandle parserHandle,
+                                        uint8 * buffer,
+                                        uint32 *size);
+
+
+/************************************************************************************************************
+ *
+ *               Movie Properties
+ *
+ ************************************************************************************************************/
+/* mandatory */
+typedef int32 (*FslParserIsSeekable)(FslParserHandle parserHandle, bool * seekable);
+
+typedef int32 (*FslParserGetMovieDuration)(FslParserHandle parserHandle,  uint64 * usDuration);
+
+typedef int32 (*FslParserGetUserData)(  FslParserHandle parserHandle,
+                                        uint32 userDataId,
+                                        uint16 ** unicodeString,
+                                        uint32 * stringLength);
+
+typedef int32 (*FslParserGetMetaData)(  FslParserHandle parserHandle,
+                                        UserDataID userDataId,
+                                        UserDataFormat * userDataFormat,
+                                        uint8 ** userData,
+                                        uint32 * userDataLength);
+
+typedef int32 (*FslParserGetNumTracks)(FslParserHandle parserHandle, uint32 * numTracks); /* single program interface */
+
+typedef int32 (*FslParserGetNumPrograms)(FslParserHandle parserHandle, uint32 * numPrograms); /* multiple program interface */
+typedef int32 (*FslParserGetProgramTracks)( FslParserHandle parserHandle,
+                                            uint32 programNum,
+                                            uint32 * numTracks,
+                                            uint32 ** ppTrackNumList);
+
+/************************************************************************************************************
+ *
+ *              General Track Properties
+ *
+ ************************************************************************************************************/
+typedef int32 (*FslParserGetTrackType)( FslParserHandle parserHandle,
+                                        uint32 trackNum,
+                                        uint32 * mediaType,
+                                        uint32 * decoderType,
+                                        uint32 * decoderSubtype);
+
+typedef int32 (*FslParserGetTrackDuration)( FslParserHandle parserHandle,
+                                            uint32 trackNum,
+                                            uint64 * usDuration); /* Duration 0 means an empty track */
+
+typedef int32 (*FslParserGetLanguage)(  FslParserHandle parserHandle,
+                                        uint32 trackNum,
+                                        uint8 * threeCharCode);
+
+/* optional */
+typedef int32 (*FslParserGetBitRate)(   FslParserHandle parserHandle,
+                                        uint32 trackNum,
+                                        uint32 * bitrate);
+
+typedef int32 (*FslParserGetDecSpecificInfo)(   FslParserHandle parserHandle,
+                                                uint32 trackNum,
+                                                uint8 ** data,
+                                                uint32 * size);
+
+
+/************************************************************************************************************
+ *
+ *               Video Properties, only for video media
+ *
+ ************************************************************************************************************/
+/* mandatory */
+typedef    int32 (*FslParserGetVideoFrameWidth)(FslParserHandle parserHandle, uint32 trackNum, uint32 *width);
+
+typedef    int32 (*FslParserGetVideoFrameHeight)(FslParserHandle parserHandle, uint32 trackNum, uint32 *height);
+
+/* optional */
+typedef    int32 (*FslParserGetVideoFrameRate)( FslParserHandle parserHandle,
+                                                uint32 trackNum,
+                                                uint32 * rate,
+                                                uint32 * scale);
+
+typedef    int32 (*FslParserGetVideoFrameRotation)(FslParserHandle parserHandle, uint32 trackNum, uint32 *rotation);
+
+/************************************************************************************************************
+ *
+ *               Audio Properties
+ *
+ ************************************************************************************************************/
+/* mandatory */
+typedef int32 (*FslParserGetAudioNumChannels)(  FslParserHandle parserHandle,
+                                                uint32 trackNum,
+                                                uint32 * numchannels);
+
+typedef int32 (*FslParserGetAudioSampleRate)(   FslParserHandle parserHandle,
+                                                uint32 trackNum,
+                                                uint32 * sampleRate);
+
+typedef int32 (*FslParserGetAudioBitsPerSample)(FslParserHandle parserHandle,
+                                                uint32 trackNum,
+                                                uint32 * bitsPerSample); /* bit depth */
+
+/* optional */
+typedef int32 (*FslParserGetAudioBlockAlign)(FslParserHandle parserHandle,
+                                             uint32 trackNum,
+                                             uint32 * blockAlign);
+
+typedef int32 (*FslParserGetAudioBitsPerFrame)( FslParserHandle parserHandle,
+                                                uint32 trackNum,
+                                                uint32 *bits_per_frame); /* for Real audio */
+
+typedef int32 (*FslParserGetAudioChannelMask)(  FslParserHandle parserHandle,
+                                                uint32 trackNum,
+                                                uint32 * channelMask); /* for WMA audio */
+
+
+/************************************************************************************************************
+ *
+ *               Text/Subtitle Properties
+ *
+ ************************************************************************************************************/
+/* mandatory */
+typedef int32 (*FslParserGetTextTrackWidth)(FslParserHandle parserHandle,
+                                            uint32 trackNum,
+                                            uint32 * width);
+
+typedef int32 (*FslParserGetTextTrackHeight)(   FslParserHandle parserHandle,
+                                                uint32 trackNum,
+                                                uint32 * height);
+
+
+/************************************************************************************************************
+ *
+ *               Sample Reading, Seek & Trick Mode
+ *
+ * NOTE: if the core parser can not give a valid sample duration,
+ *       setting the sample duration to ZERO is a good choice.
+ *
+ ************************************************************************************************************/
+/* mandatory */
+typedef int32 (*FslParserGetReadMode)(FslParserHandle parserHandle, uint32 * readMode);
+typedef int32 (*FslParserSetReadMode)(FslParserHandle parserHandle, uint32 readMode);
+
+typedef int32 (*FslParserEnableTrack)(  FslParserHandle parserHandle,
+                                        uint32 trackNum,
+                                        bool enable);
+
+typedef int32 (*FslParserGetNextSample)(FslParserHandle parserHandle,
+                                        uint32 trackNum,
+                                        uint8 ** sampleBuffer,
+                                        void  ** bufferContext,
+                                        uint32 * dataSize,
+                                        uint64 * usStartTime,
+                                        uint64 * usDuration,
+                                        uint32 * sampleFlags); /* Only for track-based sample reading. The application tell which track to read.*/
+
+
+/* optional */
+typedef int32 (*FslParserGetNextSyncSample)(FslParserHandle parserHandle,
+                                            uint32 direction,
+                                            uint32 trackNum,
+                                            uint8 ** sampleBuffer,
+                                            void  ** bufferContext,
+                                            uint32 * dataSize,
+                                            uint64 * usStartTime,
+                                            uint64 * usDuration,
+                                            uint32 * flags); /* only for trick mode on video track */
+
+
+typedef int32 (*FslParserGetFileNextSample)(FslParserHandle parserHandle,
+                                            uint32 * trackNum,
+                                            uint8 ** sampleBuffer,
+                                            void  ** bufferContext,
+                                            uint32 * dataSize,
+                                            uint64 * usStartTime,
+                                            uint64 * usDuration,
+                                            uint32 * sampleFlags); /* Only for file-based sample reading. The parser tell which track is being read.*/
+
+
+/* optional */
+typedef int32 (*FslParserGetFileNextSyncSample)(FslParserHandle parserHandle,
+                                            uint32 direction,
+                                            uint32 * trackNum,
+                                            uint8 ** sampleBuffer,
+                                            void  ** bufferContext,
+                                            uint32 * dataSize,
+                                            uint64 * usStartTime,
+                                            uint64 * usDuration,
+                                            uint32 * flags); /* only for trick mode on video track */
+
+
+/* mandatory */
+typedef int32 (*FslParserSeek)( FslParserHandle parserHandle,
+                                uint32 trackNum,
+                                uint64 * usTime,
+                                uint32 flag);
+
+
+
+
+/************************************************************************************************************
+ *
+ *               DLL entry point (mandatory) - to query parser interface
+ *
+ ************************************************************************************************************/
+enum /* API function ID */
+{
+    /* creation & deletion */
+    PARSER_API_GET_VERSION_INFO  = 0,
+    PARSER_API_CREATE_PARSER     = 1,
+    PARSER_API_DELETE_PARSER     = 2,
+
+    /* index export/import */
+    PARSER_API_INITIALIZE_INDEX  = 10,
+    PARSER_API_IMPORT_INDEX      = 11,
+    PARSER_API_EXPORT_INDEX      = 12,
+
+
+    /* movie properties */
+    PARSER_API_IS_MOVIE_SEEKABLE    = 20,
+    PARSER_API_GET_MOVIE_DURATION   = 21,
+    PARSER_API_GET_USER_DATA       = 22,
+    PARSER_API_GET_META_DATA       = 23,
+
+    PARSER_API_GET_NUM_TRACKS       = 25,
+
+    PARSER_API_GET_NUM_PROGRAMS     = 26,
+    PARSER_API_GET_PROGRAM_TRACKS   = 27,
+
+
+    /* generic track properties */
+    PARSER_API_GET_TRACK_TYPE                   = 30,
+    PARSER_API_GET_TRACK_DURATION               = 31,
+    PARSER_API_GET_LANGUAGE                     = 32,
+    PARSER_API_GET_BITRATE                      = 36,
+    PARSER_API_GET_DECODER_SPECIFIC_INFO        = 37,
+
+
+    /* video properties */
+    PARSER_API_GET_VIDEO_FRAME_WIDTH        = 50,
+    PARSER_API_GET_VIDEO_FRAME_HEIGHT       = 51,
+    PARSER_API_GET_VIDEO_FRAME_RATE         = 52,
+    PARSER_API_GET_VIDEO_FRAME_ROTATION     = 53,
+
+
+    /* audio properties */
+    PARSER_API_GET_AUDIO_NUM_CHANNELS       = 60,
+    PARSER_API_GET_AUDIO_SAMPLE_RATE        = 61,
+    PARSER_API_GET_AUDIO_BITS_PER_SAMPLE    = 62,
+
+    PARSER_API_GET_AUDIO_BLOCK_ALIGN        = 65,
+    PARSER_API_GET_AUDIO_CHANNEL_MASK       = 66,
+    PARSER_API_GET_AUDIO_BITS_PER_FRAME     = 67,
+
+
+    /* text/subtitle properties */
+    PARSER_API_GET_TEXT_TRACK_WIDTH = 80,
+    PARSER_API_GET_TEXT_TRACK_HEIGHT= 81,
+
+    /* sample reading, seek & trick mode */
+    PARSER_API_GET_READ_MODE = 100,
+    PARSER_API_SET_READ_MODE = 101,
+
+    PARSER_API_ENABLE_TRACK = 105,
+
+    PARSER_API_GET_NEXT_SAMPLE = 110,
+    PARSER_API_GET_NEXT_SYNC_SAMPLE = 111,
+
+
+    PARSER_API_GET_FILE_NEXT_SAMPLE = 115,
+    PARSER_API_GET_FILE_NEXT_SYNC_SAMPLE = 116,
+
+
+    PARSER_API_SEEK  = 120
+
+
+};
+
+/* prototype of entry point */
+typedef int32 (*tFslParserQueryInterface)(uint32 id, void ** func);
+
+/*
+Every core parser shall implement this function and tell a specific API function pointer.
+If the queried API is not implemented, the parser shall set funtion pointer to NULL and return PARSER_SUCCESS. */
+
+EXTERN int32 FslParserQueryInterface(uint32 id, void ** func);
+
+
+#endif /* _FSL_PARSER_COMMON_H */
+
--- /dev/null
+++ gst-fsl-plugins-3.0.7/inc/core_lib/parser/fsl_types.h
@@ -0,0 +1,71 @@
+/*
+* Copyright (c) 2011-2012, Freescale Semiconductor, Inc. 
+ */
+
+/*
+* This library is free software; you can redistribute it and/or
+* modify it under the terms of the GNU Lesser General Public
+* License as published by the Free Software Foundation; either
+* version 2.1 of the License, or (at your option) any later version.
+*
+* This library is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* Lesser General Public License for more details.
+*
+* You should have received a copy of the GNU Lesser General Public
+* License along with this library; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+/*
+*  History :
+*  Date             Author              Version    Description
+*
+*  Aug,2009         B06543              0.1        Initial Version
+*
+*/
+
+#ifndef _FSL_MMLAYER_TYPES_H
+#define _FSL_MMLAYER_TYPES_H
+
+#include <stdio.h>
+
+#ifndef uint64
+#ifdef WIN32
+	typedef  unsigned __int64 uint64;	
+#else
+	typedef  unsigned long long uint64;	
+#endif
+#endif /*uint64*/
+
+
+#ifndef int64
+#ifdef WIN32	
+	typedef  __int64 int64;
+#else	
+	typedef  long long int64;
+#endif
+#endif /*int64*/
+
+typedef unsigned long uint32;
+typedef unsigned short uint16;
+typedef unsigned char uint8;
+typedef long int32;
+typedef short int16;
+typedef char int8;
+
+#ifndef bool
+    #define bool int
+#endif
+
+#ifndef TRUE
+    #define TRUE 1    
+#endif
+
+#ifndef FALSE
+    #define FALSE 0    
+#endif
+
+#endif /* _FSL_MMLAYER_TYPES_H */
+
--- /dev/null
+++ gst-fsl-plugins-3.0.7/inc/core_lib/uni_audio/fsl_unia.h
@@ -0,0 +1,324 @@
+
+/*
+* Copyright (c) 2011-2013, Freescale Semiconductor, Inc. 
+ */
+
+/*
+* This library is free software; you can redistribute it and/or
+* modify it under the terms of the GNU Lesser General Public
+* License as published by the Free Software Foundation; either
+* version 2.1 of the License, or (at your option) any later version.
+*
+* This library is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* Lesser General Public License for more details.
+*
+* You should have received a copy of the GNU Lesser General Public
+* License along with this library; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+/*
+ *
+ *  History :
+ *  Date             Author              Version    Description
+ *
+ *  Sep, 2011        Lyon               1.0        Initial Version
+ *
+ */
+
+#ifndef _Uni_ADEC_WRAPPER_H_
+#define _Uni_ADEC_WRAPPER_H_
+
+#include "fsl_types.h"
+
+
+#ifdef __cplusplus
+#define EXTERN extern "C"
+#else
+#define EXTERN
+#endif
+
+
+/* Warning:
+ * It's not recommended to use any enum types as API arguments or return value!
+ * Please use data types that can explicitly tell the data length and asign them the listed enum values.
+ * It's because different compilers can treat enum as different types such as integer or unsinged char.
+ * If the ACodec library and plug-in(filter) are built by different compliers, the data length mismatch
+ * will cause error.
+ */
+ typedef void * UniACodec_Handle;
+//typedef void * UniACodec_Config;
+//typedef void * UniACodec_Info;
+
+/*
+ * Common error codes of ACodec,
+ * within the range [-100 , +100].
+ * Different ACodecs can extend the format specific errors OUTSIDE this range,
+ * in their own API header files.
+ */
+typedef enum
+{
+    ACODEC_SUCCESS = 0,
+      
+    ACODEC_ERROR_STREAM,
+    ACODEC_PARA_ERROR,
+    ACODEC_INSUFFICIENT_MEM,
+    ACODEC_ERR_UNKNOWN,
+    ACODEC_PROFILE_NOT_SUPPORT,
+    ACODEC_INIT_ERR,
+    
+    ACODEC_NOT_ENOUGH_DATA = 0x100,
+    ACODEC_CAPIBILITY_CHANGE = 0x200, /* output format changes, caller should reget format from getparameter API */
+    ACODEC_END_OF_STREAM = 0x300, /* no output */
+} UA_ERROR_TYPE;
+
+
+/* Parameter type to Set /Get */
+typedef enum
+{
+/* Set parmameters */
+/* common  */
+    UNIA_SAMPLERATE= 0,
+    UNIA_CHANNEL,
+    UNIA_FRAMED,
+    UNIA_DEPTH,
+    UNIA_CODEC_DATA,
+    UNIA_BITRATE,
+    UNIA_DOWNMIX_STEREO,
+    UNIA_STREAM_TYPE,
+    UNIA_CHAN_MAP_TABLE,
+    //UNIA_CHANNEL_MASK,
+    
+/* dedicate for wma */
+    UNIA_WMA_BlOCKALIGN= 0x100,
+    UNIA_WMA_VERSION,
+
+/*dedicate for RealAudio */
+	UNIA_RA_FLAVOR_INDEX = 0x110,
+	UNIA_RA_FRAME_BITS,
+	
+/* Get parmameters */
+    UNIA_CODEC_DESCRIPTION= 0x200, 
+    UNIA_OUTPUT_PCM_FORMAT,
+    UNIA_CONSUMED_LENGTH,
+    UNIA_OUTBUF_ALLOC_SIZE,  /* used for allocate output buffer outside */
+    
+    UA_TYPE_MAX
+} UA_ParaType;
+
+
+
+typedef enum
+{
+  UA_CHANNEL_FRONT_MONO,
+  UA_CHANNEL_FRONT_LEFT,
+  UA_CHANNEL_FRONT_RIGHT,
+  
+  UA_CHANNEL_REAR_CENTER,
+  UA_CHANNEL_REAR_LEFT,
+  UA_CHANNEL_REAR_RIGHT,
+
+  UA_CHANNEL_LFE,
+
+  UA_CHANNEL_FRONT_CENTER,
+  UA_CHANNEL_FRONT_LEFT_CENTER,
+  UA_CHANNEL_FRONT_RIGHT_CENTER,
+
+  UA_CHANNEL_SIDE_LEFT,
+  UA_CHANNEL_SIDE_RIGHT,
+
+  UA_CHANNEL_MAX
+  
+}UA_CHANNEL_LAYOUT;
+
+typedef enum
+{
+    STREAM_UNKNOW = 0,
+    STREAM_ADTS,
+    STREAM_ADIF,
+    STREAM_RAW,  
+	
+} STREAM_TYPE;
+
+/*********************************************************************
+ * Uni Audio memory callback funtion pointer table.
+ *********************************************************************/
+typedef struct
+{
+    void* (*Calloc) (uint32 numElements, uint32 size);
+    void* (*Malloc) (uint32 size);
+    void  (*Free) (void * ptr);
+    void* (*ReAlloc)(void * ptr, uint32 size);
+}UniACodecMemoryOps; /* callback operation callback table */
+
+typedef struct
+{
+  uint32 samplerate;
+  uint32 width;
+  uint32 depth;
+  uint32 channels;
+  uint32 endian;
+  bool interleave;
+  uint32 layout[UA_CHANNEL_MAX];
+  bool chan_pos_set;  // indicate if channel position is set outside or use codec default
+}UniAcodecOutputPCMFormat;
+
+
+typedef struct 
+{
+     uint32 size;		/* The size in bytes of the data in this buffer */
+     char * buf;		/* Buffer pointer */
+}UniACodecParameterBuffer;
+
+typedef struct
+{   uint32 size;
+    uint32* channel_table[10]; //assume the max channel is less than 10
+}CHAN_TABLE;
+
+typedef struct
+{
+#if !defined(RVDS)
+    union {
+#endif
+        uint32 samplerate;
+        uint32 channels;
+        uint32 bitrate;
+        uint32 depth;
+        uint32 blockalign;
+        uint32 version;
+        bool downmix;
+        bool framed;
+        UniACodecParameterBuffer codecData;
+        STREAM_TYPE stream_type;
+        CHAN_TABLE chan_map_tab;
+		
+		/* for real audio decoder */
+        uint32 frame_bits;
+		uint32 flavor_index;
+		
+        char ** codecDesc;
+        UniAcodecOutputPCMFormat outputFormat;
+        uint32 consumed_length;
+        uint32 outbuf_alloc_size;
+#if !defined(RVDS)        
+    };
+#endif
+}UniACodecParameter;
+
+
+/* typedef struct
+{
+    uint32 (*wma10dec_callback) (void *state, uint64 offset, uint32 * num_bytes, uint8 **ppData, void* pAppContext, uint32 *compress_payload);
+
+}UniACodecCallbackOps;
+*/
+/*********************************************************************************************************
+ *                  API Funtion Prototypes List
+ *
+ * There are mandotory and optional APIs.
+ * A core wrapper must implent the mandory APIs while need not implement the optional one.
+ * And in its DLL entry point "UniACodecInit", it shall set the not-implemented function pointers to NULL.
+ *
+ *********************************************************************************************************/
+/************************************************************************************************************
+ *
+ *               DLL entry point (mandatory) - to query ACodec interface
+ *
+ ************************************************************************************************************/
+/* prototype of entry point */
+typedef int32 (*tUniACodecQueryInterface)(uint32 id, void ** func);
+
+/*
+Every core ACodec shall implement this function and tell a specific API function pointer.
+If the queried API is not implemented, the ACodec shall set funtion pointer to NULL and return ACODEC_SUCCESS. */
+
+EXTERN int32 UniACodecQueryInterface(uint32 id, void ** func);
+
+
+/*******************************************************************
+ * Codec Version Info
+*******************************************************************/
+typedef const char * (*UniACodecVersionInfo)();
+
+/*******************************************************************
+ * Codec  Create & Delete
+*******************************************************************/
+typedef UniACodec_Handle (*UniACodecCreate)(  UniACodecMemoryOps * memOps);
+
+typedef int32 (*UniACodecDelete) (UniACodec_Handle pua_handle);
+
+typedef int32 (*UniACodecReset) (UniACodec_Handle pua_handle);
+
+/*******************************************************************
+ * Codec  Initializaation
+*******************************************************************/
+/*typedef int32  (*UniACodecInit) (UniACodec_Handle pua_handle,
+                                    uint8 * InputBuffer,
+                                    uint32 inputLength,
+                                    uint8 * codec_data);
+*/
+/*******************************************************************
+ * Codec Query Memory
+*******************************************************************/
+//typedef int32  (*UniACodecQueryMem) (UniACodec_Config pADec_config);
+
+/*******************************************************************
+ * Codec set  & get parameter
+*******************************************************************/
+typedef int32 (*UniACodecSetParameter) (UniACodec_Handle pua_handle, UA_ParaType ParaType, UniACodecParameter * parameter);
+
+typedef int32 (*UniACodecGetParameter) (UniACodec_Handle pua_handle, UA_ParaType ParaType, UniACodecParameter * parameter);
+
+/*******************************************************************
+ * Codec decode & encode frame
+*******************************************************************/
+typedef int32 (*UniACodec_decode_frame) (UniACodec_Handle pua_handle,
+                                         uint8 * InputBuf,
+                                         uint32 InputSize,
+                                         uint32 * offset,
+                                         uint8 ** OutputBuf,
+                                         uint32 *OutputSize);
+
+/*
+typedef int32 (*UniACodec_encode_frame) (UniACodec_Handle pua_handle,
+                                         uint8 * InputBuf,
+                                         uint32 InputLength,
+                                         uint32 * out_buf
+                                         uint32 end_flag
+                                         UA_ERROR_TYPE error_ret);
+*/
+
+typedef char * (*UniACodec_get_last_error) (UniACodec_Handle pua_handle);
+
+/*******************************************************************
+ *
+API function ID
+*******************************************************************/
+
+enum /* API function ID */
+{
+    ACODEC_API_GET_VERSION_INFO  = 0x0,
+    /* creation & deletion */
+    ACODEC_API_CREATE_CODEC     = 0x1,
+    ACODEC_API_DELETE_CODEC     = 0x2,
+    /* reset */
+    ACODEC_API_RESET_CODEC = 0x3,
+
+    /* set parameter */
+    ACODEC_API_SET_PARAMETER  = 0x10,
+    ACODEC_API_GET_PARAMETER  = 0x11,
+
+    /* process frame */
+    ACODEC_API_DEC_FRAME    = 0x20,
+    //ACODEC_API_ENC_FRAME    = 0x21,
+
+    ACODEC_API_GET_LAST_ERROR = 0x1000,
+
+};
+
+
+
+#endif /* _Uni_ADEC_WRAPPER_H_ */
+
--- /dev/null
+++ gst-fsl-plugins-3.0.7/inc/core_lib/uni_audio/fsl_types.h
@@ -0,0 +1,76 @@
+
+/*
+* Copyright (c) 2009-2010, 2013, Freescale Semiconductor, Inc. 
+ */
+
+/*
+* This library is free software; you can redistribute it and/or
+* modify it under the terms of the GNU Lesser General Public
+* License as published by the Free Software Foundation; either
+* version 2.1 of the License, or (at your option) any later version.
+*
+* This library is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* Lesser General Public License for more details.
+*
+* You should have received a copy of the GNU Lesser General Public
+* License along with this library; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+/***********************************************************************
+*
+*  History :
+*  Date             Author              Version    Description
+*
+*  Aug,2009         B06543              0.1        Initial Version
+*
+*/
+
+#ifndef _FSL_MMLAYER_TYPES_H
+#define _FSL_MMLAYER_TYPES_H
+
+#include <stdio.h>
+
+#ifndef uint64
+#ifdef WIN32
+	typedef  unsigned __int64 uint64;	
+#else
+	typedef  unsigned long long uint64;	
+#endif
+#endif /*uint64*/
+
+
+#ifndef int64
+#ifdef WIN32	
+	typedef  __int64 int64;
+#else	
+	typedef  long long int64;
+#endif
+#endif /*int64*/
+
+typedef unsigned long uint32;
+typedef unsigned short uint16;
+typedef unsigned char uint8;
+typedef long int32;
+typedef short int16;
+typedef char int8;
+
+#ifndef bool
+    #define bool int
+#endif
+
+#ifndef TRUE
+    #define TRUE 1    
+#endif
+
+#ifndef FALSE
+    #define FALSE 0    
+#endif
+
+#ifndef NULL
+    #define NULL (void *)0
+#endif
+#endif /* _FSL_MMLAYER_TYPES_H */
+
--- gst-fsl-plugins-3.0.7.orig/src/video/vpu/src/vpuenc.c
+++ gst-fsl-plugins-3.0.7/src/video/vpu/src/vpuenc.c
@@ -421,10 +421,10 @@ vpuenc_core_init (GstVpuEnc * vpuenc)
 
   vpuenc->frame_cnt = 0;
   vpuenc->codec_data = NULL;
+  vpuenc->frameblock = NULL;
   vpuenc->mems = NULL;
   vpuenc->tsm = createTSManager (VPUENC_TS_BUFFER_LENGTH_DEFAULT);
   vpuenc->tsm_mode = MODE_AI;
-  vpuenc->codec_data = NULL;
 
   vpuenc->ispec.buffer_align = 1;
   vpuenc->ispec.tiled = FALSE;
@@ -475,6 +475,11 @@ vpuenc_core_deinit (GstVpuEnc * vpuenc)
     vpuenc->codec_data = NULL;
   }
 
+  if (vpuenc->frameblock) {
+      vpuenc_core_mem_free_dma_buffer (vpuenc->frameblock);
+      vpuenc->frameblock = NULL;
+  }
+
   if (vpuenc->context.handle) {
     CORE_API (VPU_EncClose,, core_ret, vpuenc->context.handle);
     vpuenc->context.handle = 0;
@@ -972,13 +977,9 @@ gst_vpuenc_setcaps (GstPad * pad, GstCap
       }
     }
 
-    if (vpuenc->options.force_framerate) {
-      vpuenc->frame_interval =
-          gst_util_uint64_scale_int (GST_SECOND, vpuenc->options.framerate_de,
-          vpuenc->options.framerate_nu);
-    }
-
-
+    vpuenc->frame_interval =
+        gst_util_uint64_scale_int (GST_SECOND, vpuenc->options.framerate_de,
+                vpuenc->options.framerate_nu);
   } else {
     GST_ERROR ("Change support after encoding start not support");
     return FALSE;
@@ -1071,7 +1072,8 @@ gst_vpuenc_push_buffer (GstVpuEnc * vpue
     GST_BUFFER_TIMESTAMP (buffer) = GST_CLOCK_TIME_NONE;
   }
 
-  GST_BUFFER_DURATION (buffer) = 0;
+  GST_BUFFER_DURATION (buffer) = vpuenc->frame_interval;
+
   ret = gst_pad_push (vpuenc->srcpad, buffer);
   buffer = NULL;
 
@@ -1146,7 +1148,6 @@ gst_vpuenc_chain (GstPad * pad, GstBuffe
   GstVpuEnc *vpuenc;
   GstFlowReturn ret = GST_FLOW_UNEXPECTED;
   VpuEncRetCode core_ret;
-  VpuEncMem *frameblock = NULL;
 
   vpuenc = GST_VPUENC (GST_PAD_PARENT (pad));
 
@@ -1209,15 +1210,16 @@ gst_vpuenc_chain (GstPad * pad, GstBuffe
       paddr = DMABLE_BUFFER_PHY_ADDR (buffer);
       vaddr = GST_BUFFER_DATA (buffer);
     } else {
-      gint size = vpuenc->ispec.pad_frame_size + vpuenc->ispec.buffer_align - 1;
       GST_INFO ("Need memcpy input buffer, performance maybe drop");
-      if ((frameblock =
-              vpuenc_core_mem_alloc_dma_buffer (vpuenc->ispec.pad_frame_size)) == NULL) {
-        GST_ERROR ("Can not create dmaable buffer for input copy");
-        goto bail;
+      if (!vpuenc->frameblock) {
+          if ((vpuenc->frameblock =
+                      vpuenc_core_mem_alloc_dma_buffer (vpuenc->ispec.pad_frame_size)) == NULL) {
+              GST_ERROR ("Can not create dmaable buffer for input copy");
+              goto bail;
+          }
       }
-      paddr = (void *) Align (frameblock->paddr, vpuenc->ispec.buffer_align);
-      vaddr = (void *) Align (frameblock->vaddr, vpuenc->ispec.buffer_align);
+      paddr = (void *) Align (vpuenc->frameblock->paddr, vpuenc->ispec.buffer_align);
+      vaddr = (void *) Align (vpuenc->frameblock->vaddr, vpuenc->ispec.buffer_align);
       gst_vpuenc_copy_frame (vpuenc, buffer, vaddr);
     }
 
@@ -1264,6 +1266,9 @@ gst_vpuenc_chain (GstPad * pad, GstBuffe
         /* FIX ME : currently vpu wrapper still need copy since 6q does not dynamic output buffer */
         memcpy (GST_BUFFER_DATA (gstbuf), (void *) (vpuenc->obuf->vaddr),
             vpuenc->context.params.nOutOutputSize);
+        if (vpuenc->vpu_stat.out_cnt % vpuenc->options.gopsize) {
+            GST_BUFFER_FLAG_SET (gstbuf, GST_BUFFER_FLAG_DELTA_UNIT);
+        }
         vpuenc->vpu_stat.out_cnt++;
         ret = gst_vpuenc_push_buffer (vpuenc, gstbuf);
 
@@ -1282,10 +1287,6 @@ bail:
     if (buffer) {
       gst_buffer_unref (buffer);
     }
-
-    if (frameblock) {
-      vpuenc_core_mem_free_dma_buffer (frameblock);
-    }
     return ret;
   }
 }
--- gst-fsl-plugins-3.0.7.orig/src/video/vpu/src/vpuenc.h
+++ gst-fsl-plugins-3.0.7/src/video/vpu/src/vpuenc.h
@@ -181,6 +181,7 @@ struct _GstVpuEnc
   guint64 frame_cnt;
 
   GstBuffer *codec_data;
+  VpuEncMem *frameblock;
 };
 
 
--- gst-fsl-plugins-3.0.7.orig/src/video/vpu/src/vpudec.c
+++ gst-fsl-plugins-3.0.7/src/video/vpu/src/vpudec.c
@@ -179,7 +179,7 @@ static GstsutilsOptionEntry g_vpudec_opt
       G_STRUCT_OFFSET (VpuDecOption, adaptive_drop), "true"},
   {PROP_FRAMES_PLUS, "frame-plus", "addtionlal frames",
         "set number of addtional frames for smoothly playback", G_TYPE_INT,
-      G_STRUCT_OFFSET (VpuDecOption, bufferplus), "6", "1", STR_MAX_INT},
+      G_STRUCT_OFFSET (VpuDecOption, bufferplus), "6", "2", STR_MAX_INT},
   {PROP_OUTPUT_FORMAT, "output-format", "output format",
         "set raw format for output",
         G_TYPE_ENUM,
--- gst-fsl-plugins-3.0.7.orig/src/misc/v4l_sink/src/mfw_gst_v4l.c
+++ gst-fsl-plugins-3.0.7/src/misc/v4l_sink/src/mfw_gst_v4l.c
@@ -1345,7 +1345,7 @@ mfw_gst_v4l2_set_crop (MFW_GST_V4LSINK_I
   if ((!memcmp (crop, prevCrop, sizeof (struct v4l2_crop)))
       && (v4l_info->rotate == v4l_info->prevRotate)) {
     // mfw_gst_v4l2_streamoff(v4l_info);
-    return FALSE;
+    return TRUE;
 
   } else {
     memcpy (prevCrop, crop, sizeof (struct v4l2_crop));
@@ -1412,8 +1412,10 @@ mfw_gst_v4l2_display_init (MFW_GST_V4LSI
     return FALSE;
   }
   retVal = mfw_gst_v4l2_open (v4l_info);
-  if (!retVal)
+  if (!retVal) {
+    GST_ERROR ("Still not get the video information");
     return FALSE;
+  }
   mfw_gst_fb0_get_resolution (v4l_info);
 
   width = (disp_width >> 3) << 3;
--- gst-fsl-plugins-3.0.7.orig/src/misc/v4l_sink/src/mfw_gst_v4l_xlib.c
+++ gst-fsl-plugins-3.0.7/src/misc/v4l_sink/src/mfw_gst_v4l_xlib.c
@@ -339,6 +339,7 @@ mfw_gst_xv4l2_event_thread (MFW_GST_V4LS
 #ifdef _MX6
                 if ((param & PARAM_SET_V4L) == PARAM_SET_V4L)
                 {
+                    GST_INFO ("Refresh geometry and set crop.");
                     mfw_gst_xv4l2_refresh_geometry (v4l_info);
                     mfw_gst_v4l2_set_crop(v4l_info, v4l_info->disp_width, v4l_info->disp_height);
                 }
--- gst-fsl-plugins-3.0.7.orig/src/misc/v4l_sink/src/mfw_gst_xlib.c
+++ gst-fsl-plugins-3.0.7/src/misc/v4l_sink/src/mfw_gst_xlib.c
@@ -192,7 +192,7 @@ mfw_gst_x11_handle_xevents (void *contex
         return TRUE;
     }
     if (exposed) {
-        GST_INFO ("Get the expose event.");
+        GST_WARNING ("Get the expose event.");
         return TRUE;
     }
     return FALSE;
--- gst-fsl-plugins-3.0.7.orig/src/misc/v4l_sink/src/mfw_gst_v4lsink.c
+++ gst-fsl-plugins-3.0.7/src/misc/v4l_sink/src/mfw_gst_v4lsink.c
@@ -355,12 +355,11 @@ mfw_gst_v4lsink_create_event_thread (MFW
 
   } else {
     if (!(IS_PXP (v4l_info->chipcode)))
-      mfw_gst_set_gbl_alpha (v4l_info->fd_fb, 128);
+      mfw_gst_set_gbl_alpha (v4l_info->fd_fb, 0);
   }
 }
 
 
-
 /*=============================================================================
 FUNCTION:           mfw_gst_v4lsink_set_xwindow_id
 
@@ -429,6 +428,30 @@ mfw_gst_v4lsink_set_xwindow_id (GstXOver
 
 
 /*=============================================================================
+FUNCTION:           mfw_gst_v4lsink_set_window_handle
+
+DESCRIPTION:        This function handle the set_window_handle event.
+
+ARGUMENTS PASSED:
+        overlay     -  Pointer to GstXOverlay
+        handle      - Pointer to XID
+
+
+RETURN VALUE:
+
+PRE-CONDITIONS:     None
+POST-CONDITIONS:    None
+IMPORTANT NOTES:    None
+=============================================================================*/
+static void
+mfw_gst_v4lsink_set_window_handle (GstXOverlay * overlay, guintptr handle)
+{
+  GST_DEBUG("Set xwindow_id=%lu", (XID)handle);
+  mfw_gst_v4lsink_set_xwindow_id(overlay, (XID)handle);
+}
+
+
+/*=============================================================================
 FUNCTION:           mfw_gst_v4lsink_expose
 
 DESCRIPTION:        This function handle the expose event.
@@ -527,6 +550,7 @@ IMPORTANT NOTES:    None
 static void
 mfw_gst_v4lsink_xoverlay_init (GstXOverlayClass * iface)
 {
+  iface->set_window_handle = mfw_gst_v4lsink_set_window_handle;
   iface->set_xwindow_id = mfw_gst_v4lsink_set_xwindow_id;
   iface->expose = mfw_gst_v4lsink_expose;
   iface->handle_events = mfw_gst_v4lsink_set_event_handling;
@@ -1520,7 +1544,8 @@ mfw_gst_v4lsink_change_state (GstElement
           mfw_gst_v4lsink_create_event_thread (v4l_info);
 
         mfw_gst_xv4l2_refresh_geometry (v4l_info);
-      }
+      } else 
+          mfw_gst_set_gbl_alpha (v4l_info->fd_fb, 0);
 #else
       mfw_gst_set_gbl_alpha (v4l_info->fd_fb, 0);
 #endif
--- gst-fsl-plugins-3.0.7.orig/src/misc/v4l_sink/src/mfw_gst_v4lsink.h
+++ gst-fsl-plugins-3.0.7/src/misc/v4l_sink/src/mfw_gst_v4lsink.h
@@ -142,7 +142,7 @@ struct v4l2_mxc_offset
 #endif
 
 #define MAX_V4L_ALLOW_SIZE_IN_BYTE  (MAX_V4L_ALLOW_SIZE_IN_MB*1024*1024)
-#define MIN_QUEUE_NUM             1 
+#define MIN_QUEUE_NUM             2 
 
 G_BEGIN_DECLS
 /* #defines don't like whitespacey bits */
